#### 1. Оптимизация запросов.
##### Что это:

1) Оптимизация запросов – процесс выбора наиболее эффективного плана из одной или многих стратегий, которые могут быть применены для обработки запросов.
2) Один из пунктов оптимизации возникает на уровне реляционной алгебры, когда система пытается найти выражение, которое эквивалентно указанному выражению, но наиболее эффективно для вычисления.
3) Другой пункт оптимизации – это выбор детализированной стратегии для обработки запроса, такой как выбор алгоритма для выполнения операции.

##### Общий план поиска.
1) Для каждого плана посчитать стоимость, выбрать наименьший.
Берете план запроса и делаете цикл:
```
для каждого нового элемента
	для каждого правила
		пытаемся создать выражение на основе правила эквивалентности
		если выражение новое, добавляем в список
```
2) Получение всевозможных эквивалентных планов запроса.
3) По каждому логическому запросу сгенерировать всевозможные физические планы запросов.

##### Возможные оптимизации.
- Использование указателей на подмножества планов.
- Уменьшение количества генерируемых планов запроса (на основе эвристик и стат. данных).
- используется информация из системного каталога (INFORMATION_SCHEMA).
- Разделяй и властвуй для физ. планов.
- Кэширование планов.

##### INFORMATION_SCHEMA.
- Количество кортежей в отношении - n(r).
- Количество блоков, содержащих кортежи отношения - b(r).
- Данные об устройстве кортежа.
- Распределение количества кортежей в блоке - f(r).
- Гистограмма уникальных значений в таблице по полям.
- b(r) ≈ n(r)/f(r)


#### 2. Метод временных меток.

##### Основная идея метода временных меток (Timestamp Ordering, TO), состоит в следующем:
1) Если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой сериальный план, как если бы транзакция T1 была целиком выполнена до начала T2. Для этого каждой транзакции T предписывается временная метка t(T), соответствующая времени начала выполнения транзакции T.
2) При выполнении операции над объектом o транзакция T помечает его своими идентификатором, временной меткой и типом операции (чтение или изменение).

3) Перед выполнением операции над объектом o транзакция T2 выполняет следующие действия:
4) Проверяет, помечен ли объект o какой-либо транзакцией T1. Если не помечен, то помечает этот объект своей временной меткой и типом операции и выполняет операцию.
5) Иначе (если o помечен T1) транзакция T2 проверяет, не завершилась ли транзакция T1, пометившая этот объект. Если транзакция T1 закончилась, то T2 помечает объект o и выполняет свою операцию.
6) Иначе (если T1 не завершилась) T2 проверяет конфликтность операций. Если операции неконфликтны, то при объекте o запоминается идентификатор транзакции T2, остается или проставляется временная метка с меньшим значением, и транзакция T2 выполняет свою операцию.

7) Иначе (если операции транзакций T2 и T1 конфликтуют), то если t(T2) > t(T1) (т.е. транзакция T1 «моложе» T2), то производится откат T1 и всех других транзакций, идентификаторы которых сохранены при объекте o, и T2 выполняет свою операцию.
8) Если же t(T2) ≤ t(T1) (T1 «старше» T2), то производится откат T2, и T2 получает новую временную метку и начинается заново.
##### К недостаткам метода TO относятся:
- Потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а построение графа ожидания в распределенных системах стоит очень дорого.
