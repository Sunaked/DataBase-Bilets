# Меры стоимости запросов(лекции 10 - ?)
**Меры стоимости запроса**
-   Многие факторы участвуют при оценке времени
-   Доступ к диску, CPU, и сетевые коммуникации
-   Стоимость может быть вычислена на основе
-   времени ответа, т.е. общее время ответа на запросы
-   общее потребление ресурсов
-   Будет рассматривать метрику по потреблению ресурсов
-   Время ответа сложнее вычислить, уменьшение потребления ресурсов – хорошая метрика в общей (shared) БД
-   Мы игнорируем стоимость CPU для простоты
-   Реальные системы используют стоимость CPU для оценки
-   Стоимость сети рассматривается для параллельных систем
-   Опишем, как вычислить стоимость для каждой операции
-   Стоимость записи на диск игнорируем для простоты

-   Стоимость доступа на диск может быть рассчитана как:
	-   Число поисков                *  среднее время поиска 
	-   Число блоков чтения     *  среднее время чтения блока
	-   Число блоков записи     *  среднее время записи блока
-   Для простоты учитываем число трансфера блока с диска  и число поисков как меры стоимости
	-   tₜ – время для трансфера одного блока
		-   Для простоты предполагаем, что стоимость записи соответствует  стоимости чтения
	-   tₛ – время для одного поиска
	-   Стоимость для b трансферов блоков и S поисков b * tₜ + S * tₛ 
-   tS и tₜ зависят от того, где хранятся данные; с 4 KB блоками:
-   HDD: tₛ = 4 msec и tₜ =0.1 msec
-   SSD: : tₛ = 20-90 microsec и tₜ = 2-10 microsec для  4KB
-   Требуемые данные могут быть уже в буфере и, следовательно, не потребуется I/O
	-   Но это сложно учитывать при оценке
-   Часть алгоритмов может уменьшать дисковое IO, если есть дополнительное место в буфере
	-   Количество реально доступной памяти в буфере зависит от параллельных запросов и процессов ОС в момент выполнения
-   Худший вариант предполагает, что изначально нет данных в буфере и только минимальное количество памяти может быть выделено для операции
	-   Более оптимистичные сценарии обычно предполагают наличие места
## Операция выборки
-   **Скан (обход) файла**
-   Алгоритм A1 (линейный поиск). Обходит каждый блок файла и тестирует все записи на условие отбора.
	-   Стоимость выполнения= br трансферов блока + 1 поиск
		-   bᵣ  определяет число блоков записей в отношении r
	-   Если выборка по ключевом атрибуте, то можно остановиться при нахождении
		-   Стоимость = (bᵣ /2) трансферов блока + 1 поиск
	-   Линейный поиск может применяться независимо от 
		-   Условия выборки
		-   Сортировки записей в файле
		-   Доступности индексов
-   Замечание: для бинарного поиск обычно нет смысла, так как данные не хранятся последовательно
	-   И бинарный поиск требует большее число поисков
## Выборка при использовании индексов
-   **Обход индекса** – алгоритмы поиска, использующие индекс 
	-   Условие выборки должно содержать ключ поиска в индексе.
-   **A2 (кластерный индекс, равенство по ключу)**. Вывод: одна запись, которая подходит по равенству по ключу
	-   Стоимость = (hᵢ + 1) * (tₜ + tₛ)
-   **A3 (кластерный индекс, равенство не по ключу)**. Вывод: несколько записей. 
	-   Записи должны быть на последовательных блоках
		-   Пусть b = число блоков, содержащих совпадающие записи
	-   Стоимость= hᵢ * (tₜ + tₛ) + tₛ + tₜ * b
-   **A4 (вторичный индекс, равенство (не) по ключу).**
	-   Возвращает одну запись, если ключ поиска уникален
		-   Стоимость= (hᵢ + 1) * (tₜ + tₛ)
	-   Возвращает несколько записей, если ключ поиска м.б. не уникален
		-   Каждая из n совпадающих записей может быть в разных блоках
		-   Стоимость =  (hᵢ + n) * (tₜ + tₛ) 
			-   Может быть очень дорогой операцией
## Выборки, включающие сравнения
```
1) ≥,≤ - subscript(нижний индекс)
```
-   Можно разработать выборки формы σₐ≤ᵥ(r) или σₐ≥ᵥ(r) через
	-    линейный обход файла,
	-    использование индексов следующими способами
-   **A5 (кластерный индекс, сравнение)**. (Отношение отсортировано по A)
	-   Для σₐ≥ᵥ(r)  используется индекс для нахождения первого кортежа ≥ v  и 	далее последовательный обход отношения
	-   Для σₐ≤ᵥ(r) просто последовательный обход отношения до момента, как кортеж> v;**
-   Можно разработать выборки формы σₐ≤ᵥ(r) или σₐ≥ᵥ(r) через
	-    линейный обход файла,
	-    использование индексов следующими способами
-   **A6 (кластерный индекс, сравнение)**. 
	-   Для σₐ≥ᵥ(r)  используется индекс для нахождения первой записи ≥ v  и осуществлять последовательный поиск для нахождения указателя на записи
	-   Для σₐ≤ᵥ(r) обходить корневые страницы до условия > v
	-   Если условие не соответствует порядку А, то может потребоваться одно чтение на запись

```
1) θ - subscript(нижний индекс)
```

## Реализация сложных выборок
```
1) θ - subscript(нижний индекс)
```
-   Конъюнкция:  σθ₁∧θ₂∧. . . ₔₙ(r)  
-  **A7 (конъюнктивная выборка с использованием одиночного индекса) **.  
	-   Все условия по индексу проверяем
	-   Остальные проверки в буфере памяти
-    **A8 (конъктивная выборка с использованием сложного индекса **.  
	-   Используется подходящий сложный составной индекс.
-    **A9 (конъюнктивная выборка с пересечением идентификаторов) **. 
	-   Пересекаем указатели, подходящие для индексов
	-   Остальные проверки в памяти
## Алгоритмы для сложных выборок
```
1) θ - subscript(нижний индекс)
2) ¬ - subscript(нижний индекс)
```
-   **Дизъюнкция:**σ`θ`₁∨`θ`₂ ∨. . . `θ`ₙ(r). 
-   **A10 (дизъюнктивная выборка по объединению идентификаторов)**. 
	-   Применима, если все условия имеют индексы
		-   В другом случае линейный поиск
-   **Отрицание:**  σ`¬θ`(r)
	-   Линейный поиск по файлу
	-   Если не много записей `¬θ`, и индекс применим по `θ`
		-    Найти подходящие записи по индексу
## Сортировка
-   Можно построить индекс по отношению, и использовать индекс для чтения в том же порядке. Для каждого кортежа может потребоваться только одно чтение.
-   Для отношений, помещающихся в памяти, можно использовать стандартные сортировки, например quicksort. Для не помещающихся  external sort-merge.
## Стоимость сортировки
```
1) θ - subscript(нижний индекс)
```
Пусть bᵣ - число блоков в отношение r. Первая стадия – чтение каждого блока отношения и его перезапись - 2bᵣ. Изначальное число пробегов - bᵣ/M
Для эффективного слияния требуется b`b` буферных блоков для каждого входа пробега и его выхода.

*images here*
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/sort_image1.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/sort_image2.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/nested_loops.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/block_sort.png)

![merge](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/merge.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/hash_join.png)
## Транзакции
#### Различаются два вида ограничений целостности: немедленно проверяемые и откладываемые.
-   К немедленно проверяемым ограничениям целостности относятся такие ограничения, проверку которых бессмысленно или даже невозможно откладывать. При их нарушениях не производится откат транзакции, а лишь отвергается соответствующий оператор. 
-   Откладываемые ограничения целостности – это ограничения на базу данных, а не на какие-либо отдельные операции. По умолчанию такие ограничения проверяются при конце транзакции, и их нарушение вызывает автоматическую замену оператора COMMIT на оператор ROLLBACK.