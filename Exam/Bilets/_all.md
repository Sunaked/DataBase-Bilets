# 1.  Функциональные зависимости и нормальные формы:
1 пункт (см. выше) находится в 9 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).
### Термины:
- **Атрибут** – _свойство_ некоторой _сущности_. Часто называется полем таблицы.
- **Домен атрибута** – _множество_ допустимых _значений_ атрибута.
- **Кортеж** – _конечное множество_ взаимосвязанных допустимых _значений_ атрибутов _сущности_ (строка таблицы).
- **Отношение** — конечное _множество кортежей_ (таблица).
- **Схема отношения** — конечное _множество атрибутов_ _сущности_. Иными словами, это структура таблицы, состоящей из конкретного набора полей.
- **Проекция** — _отношение_, _полученное_ из заданного путём _удаления_ и (или) _перестановки_ некоторых _атрибутов_.
- **Функциональная зависимость** между атрибутами (множествами атрибутов) X и Y означает, что для любого допустимого набора кортежей в данном отношении: если два кортежа совпадают по значению X, то они совпадают по значению Y. 
- **Нормальная форма** — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).
- **Метод нормальных форм** (НФ) состоит в сборе информации об объектах решения задачи в рамках одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений.
- **Цель нормализации**: исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении, редактировании и удалении кортежах (строк таблицы).
- **Аномалией** называется такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенно усложняет обработку БД. Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от не ключевых атрибутов. ![[./images/Pasted image 20220521130310.png]] ^f89791

### Функциональные зависимости
- Пусть задан экземпляр отношения $r(R)$. Пусть α,β⊆R – множество атрибутов. Экземпляр удовлетворяет функциональной зависимости α→β, если для все пар кортежей $t_1, t_2$ выполнено:$t_1[α]=t_2[α]⇒t_1[β]=t_2[β]$
Функциональная зависимость α→β выполняется для схемы отношения $r(R)$, если она выполняется для каждой функциональной зависимости.

##### Пример функциональной зависимости:
![[./images/Pasted image 20220521124925.png]]

student_id -> name
student_id -> city
student_id -> name, city
student_id, course_name -> grade

### Нормальные формы
#### Первая нормальная форма
- Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения, не должно быть повторений строк в таблице.![[./images/Pasted image 20220521130510.png]]
#### Вторая нормальная форма
- Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут **неприводимо** зависит от Первичного Ключа (ПК).
- **Неприводимость** означает, что в составе потенциального ключа _отсутствует_ _меньшее подмножество_ атрибутов, от которого можно также вывести данную функциональную зависимость.
![[./images/Pasted image 20220521130607.png]]

#### Третья нормальная форма
- Переменная отношения находится в 3НФ тогда и только тогда, когда она находится в 2НФ, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.
- Определение 3НФ не совсем подходит для следующих отношений:
	1) отношение имеет два или более потенциальных ключей;
	2) два и более потенциальных ключей являются составными;
	3) они пересекаются, т.е. имеют хотя бы один общий атрибут.

![[./images/Pasted image 20220521130644.png]]


#### Нормальная форма Бойса-Кодда (НФБК)
- Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
- Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ.

##### Пример:
Из этого 
![[./images/Pasted image 20220521130952.png]]
- следует это:
![[./images/Pasted image 20220521131020.png]]




#### Четвертая нормальная форма
- Переменная отношения находится в 4НФ, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей.
- В отношении R (A, B, C) существует многозначная зависимость R.A->R.B в том и только в том случае, если множество значений B, соответствующее паре значений A и C, зависит только от A и не зависит от С.

#### Пятая нормальная форма
- Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами:
  Если «Атрибут_1» зависит от «Атрибута_2», а «Атрибут_2» в свою очередь зависит от «Атрибута_3», а «Атрибут_3» зависит от «Атрибута_1», то все три атрибута обязательно входят в один кортеж.

#### Доменно-ключевая нормальная форма
- Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.
- Ограничение домена – ограничение, предписывающее использовать для определённого атрибута значения только из некоторого заданного домена. Ограничение по своей сути является заданием перечня (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип.
- Ограничение ключа – ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является потенциальным ключом.
- Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную отношения можно привести к ДКНФ.

#### Шестая нормальная форма
- Переменная отношения находится в 6НФ тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. 


# 2.  Методы сериализации транзакций:
2 пункт (см. выше) лежит в лекции 13 [препода по БД на гугл диске](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8)

### Сериализация транзакций:
- **Сериализация транзакций** – это механизм _одновременного_ _выполнения транзакций_ T1,T2,...,Tn по некоторому сериальному плану. 
- Пусть в системе одновременно выполняется некоторое множество транзакций S = {T1,T2,...,Tn}. План выполнения набора транзакций S, в котором, вообще говоря, чередуются или реально параллельно выполняются операции разных транзакций T1,T2,...,Tn, называется сериальным, если результат совместного выполнения транзакций эквивалентен результату некоторого последовательного выполнения этих же транзакций (Ti1,Ti2,...,Tin).

### Методы сериализации транзакций:
1) основанный на синхронизационных блокировках
2) основанный на использовании временных меток

- **Для каждого из подходов имеются две разновидности: пессимистическая и оптимистическая.**:
	1) Пессимистический - когда _конфликты_ возникают _часто_, они распознаются и _разрешаются_ _немедленно_ при их _возникновении_. 
	2) Оптимистический - метод _хорошо_ работает, _когда конфликты редки_. Любая _транзакция_, изменяющая базу данных _выполняется_ _без синхронизации_ вообще, но все её _результаты_ в базу данных _не пишутся_, а _сохраняются в её локальной памяти (до операции COMMIT)_. 

- Когда отрабатывает операция COMMIT система проигрывает транзакцию заново и смотрит не было ли конфликтов при выполнении рабочей фазы транзакции. Если конфликтов не было, то все её изменения реально записываются в БД. Если конфликты обнаруживаются, то транзакция откатывается.

### Конфликты:
- Между транзакциями T1 и T2 могут существовать следующие **виды конфликтов**:
	1) W/W (Write/Write) – транзакция T2 пытается изменять объект, изменённый не закончившейся транзакцией T1. Может привести к ситуации потерянных изменений.
	2) R/W (Read/Write) – транзакция T2 пытается изменять объект, прочитанный не закончившейся транзакцией T1. Может привести к возникновению ситуации неповторяющихся чтений.
	3) W/R (Write/Read) – транзакция T2 пытается читать объект, изменённый не закончившейся транзакцией T1. Может привести к возникновению ситуации «грязного» чтения.



# 1.  Семантическая модель Entity-Relationship, E/R-диаграммы:
1 пункт (см. выше) находится в 8 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).

_Основными понятиями_ ER-модели являются *сущность*, *связь* и *атрибут*:

**Сущность** – это реальный или представляемый _объект_, _информация_ о котором должна _сохраняться_ и _быть_ _доступной_.

**Связь** – это графическая _ассоциация_ между двумя _типами_ сущностей.

**Атрибут** - это деталь для уточнения, идентификации, классификации, числовой характеристики или выражения состояния сущности.

## Сущность:
В _диаграммах_ ER-модели _сущность представляется в виде прямоугольника_, содержащего имя сущности. При этом _имя сущности – это имя типа_, а не некоторого конкретного экземпляра этого типа.

## Связь:
_Обязательный конец_ связи _изображается_ _сплошной_ линией, а _необязательный_ – _прерывистой_ линией.

В любой **связи** выделяются _два конца_, на каждом из которых указываются: 
- имя конца связи
- степень конца связи
- обязательность связи

В месте «стыковки» связи с сущностью используются: 
- **Трёхточечный** вход в прямоугольник сущности, если для этой сущности в связи могутиспользоваться много экземпляров сущности
- **Одноточечный** вход, если в связи может (или должен) участвовать только один экземпляр сущности


## Атрибут:
Имена атрибутов заносятся в прямоугольник, изображающий сущность, под именем сущности и изображаются малыми буквами.


## При построении ER-модели используются следующие принципы: 
 1) сущности на диаграмме представляются прямоугольниками;
 2) каждый прямоугольник может иметь различные визуальные 
  атрибуты; 
 3) каждой сущности должно быть присвоено уникальное имя; 
 4) имена сущностей необходимо задавать в единственном числе; 
 5) связи на диаграмме представляются линиями, идущими от одной 
 сущности (таблицы) к другой; 
 6) каждой связи присваивается уникальное имя; 
 7) связанные таблицы разделяют на родительские и дочерние;
 8) родительские таблицы отображаются прямоугольниками с прямыми 
углами, дочерние – со скругленными

# 2.  Синхронизационные блокировки:

^3f802f

2 пункт (см. выше) находится в 13 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8)

## Чем являются синхр. блокировки:
Синхронизационные блокировки являются одним из двух подходов к сериализации транзакций.


**Метод синхронизационных блокировок** это подход, основанный на соблюдении двухфазного протокола синхронизационных захватов объектов баз данных (TwoPhase Locking Protocol, 2PL)

## Описание подхода 2PL:
(TwoPhase Locking Protocol)(2PL) Подход состоит в том, что _перед выполнением любой операции_ в транзакции T над объектом базы данных Q от имени транзакции T _запрашивается синхронизационная блокировка объекта_ Q в соответствующем режиме:
- Первая фаза транзакции (выполнение операций над базой данных) – **накопление блокировок**
- Вторая фаза (фиксация или откат) – **снятие блокировок**



## Режимы блокировок:
- S (Shared) - совместный режим, означающий совместную (по чтению) блокировку объекта. Такая блокировка требуется для операции чтения объекта.
- X (eXclusive) - монопольный режим, означающий монопольную (по записи) блокировку объекта. Требуется для выполнения операций вставки, удаления и модификации объекта.


## Уровни блокировок:
Для _согласования_ блокировок _разного уровня_ вводятся специальный протокол **гранулированных** блокировок и новые типы блокировок:
- Блокировка в режиме IS (Intented for Shared lock) некоторого составного объекта o базы данных означает намерение заблокировать некоторый объект o’, входящий в o, в _совместном_ режиме (режиме S). 
- Блокировка в режиме **IX** (Intented for eXclusive lock) некоторого составного объекта o базы данных означает намерение заблокировать некоторый объект o’, входящий в o, в _монопольном_ режиме (режиме X). 
- Блокировка в режиме **SIX** (Shared, Intented for eXclusive lock) некоторого составного объекта o базы данных означает _совместную блокировку всего этого объекта с намерением_ впоследствии блокировать какие-либо входящие в него объекты в монопольном режиме режиме X. 
	Например, если выполняется длинная операция просмотра таблицы Tab с возможностью удаления некоторых просматриваемых кортежей, то экономичнее всего заблокировать таблицу Tab в режиме SIX.

### Правила блокировок (фото):
![[./images/Pasted image 20220703130229.png]]

## Блокировка объекта одной транзакцией по чтению не совместима с блокировкой другой транзакцией того же объекта по записи:
- никакая транзакция не может изменять объект, читаемый некоторой транзакцией (кроме самой этой транзакции)
- никакой транзакции нельзя читать объект, изменяемый некоторой транзакцией (кроме самой этой транзакции)
**Правила совместимости режимов**: ![[./images/Pasted image 20220521150014.png]]



### Обнаружение тупиковых ситуаций:
В системе существует тупиковая ситуация в том и только в том случае, когда в графе ожидания транзакций имеется хотя бы один цикл. Для распознавания тупиковых ситуаций периодически производится построение графа ожидания транзакций, и в этом графе ищутся циклы.

Алгоритм редукции графа (на примере):
![[./images/Pasted image 20220702131517.png]]

#### Алгоритм редукции графа ожидания:
- Удаляются все дуги от транзакций к объектам такие, что данная транзакция не ожидает блокировки каких-либо объектов. Если транзакции не ожидают удовлетворения запроса блокировок, то они не могут создавать тупика.
- Удаляются все дуги от объектов к транзакциям такие, что у транзакции нет заблокированных объектов. Если транзакции ожидают удовлетворения блокировок, но не удерживают заблокированных объектов, то они не могут создавать тупика.
- ![[./images/Pasted image 20220702131637.png]]

- Для объектов без входящих дуг, но с исходящими дугами, ориентация одной произвольной исходящей дуги изменяется на противоположную - это моделирует удовлетворение запроса блокировки.
- Снова повторяются описанные действия с шага 1 до тех пор, пока не прекратится удаление дуг.
- Если в результате работы этого алгоритма в графе останутся дуги, то они обязательно образуют цикл.
- ![[./images/Pasted image 20220702131710.png]]

![[./images/Pasted image 20220702131808.png]]
### Разрушение тупиков:
Разрушение тупика начинается с выбора в цикле транзакции-жертвы, т.е. транзакции, которой решено пожертвовать, чтобы обеспечить возможность продолжения работы других транзакций. Критерии выбора транзакции:
- Транзакция, которая удерживает наибольшее число блокировок объектов
- Транзакция, которая существует в системе в течение наименьшего времени
- Случайным образом

Обычно при выборе транзакции-жертвы используется многофакторная оценка её стоимости.
После выбора транзакции-жертвы выполняется откат этой транзакции, который может носить полный или частичный (до некоторой точки сохранения) характер. При этом, естественно, освобождаются блокировки, и может быть продолжено выполнение других транзакций.











#### Определения:
  1) _Транзакция_ - это последовательность операций над БД, рассматриваемых СУБД как единое целое: либо все операции внутри транзакции выполняются, либо ни одна не выполняется. Транзакция в SQL – это несколько последовательных инструкций SQL, которые вместе образуют логическую единицу работы (unit of work).
  2) _ACID_ - Atomic (атомарность) Consistent (целостность) Isolation (изолированность) Durability (долговечность) 
  3) _Атомарность_ - результаты всех операций, успешно выполненных в пределах транзакции, должны быть отражены в состоянии базы данных, либо в состоянии базы данных не должно быть отражено действие ни одной операции. **Иногда называют "Все или ничего"**.
##### Все или ничего:
1) При успешном завершении транзакции оператором COMMIT
	- результаты гарантированно фиксируются во внешней памяти
	- смысл термина commit состоит в запросе «фиксации» результатов транзакции
1) При завершении транзакции оператором ROLLBACK 
	- результаты гарантированно отсутствуют во внешней памяти
	- смысл термина rollback состоит в запросе ликвидации результатов транзакции

##### Согласованность:
- Означает, что транзакция может быть успешно завершена с фиксацией результатов своих операций только в том случае, когда действия операций не нарушают целостность базы данных, т.е. удовлетворяют набору ограничений целостности, определенных для этой базы данных. 
- Это свойство расширяется тем, что во время выполнения транзакции разрешается устанавливать точки согласованности и явным образом проверять ограничения целостности. 

##### Изоляция:
- Требуется, чтобы две одновременно выполняемые транзакции никаким образом не действовали одна на другую. 
- Результаты выполнения операций транзакции T1 не должны быть видны никакой другой транзакции T2 до тех пор, пока транзакция T1 не завершится успешным образом.

##### Долговечность:
- После успешного завершения транзакции, все изменения, которые были внесены в состояние базы данных операциями этой транзакции, должны гарантированно сохраняться, даже в случае сбоев аппаратуры или программного обеспечения.


#### Целостность БД:

Часто база данных обладает такими ограничениями целостности, которые просто _невозможно не нарушить_, выполняя только один оператор изменения базы данных. Для поддержки подобных ограничений целостности допускается их нарушение внутри транзакции с тем условием, чтобы _к моменту завершения транзакции условия целостности были соблюдены_. 

_Начальная проверка_ _целостности_ БД проверяется при _первоначальной загрузке БД_, что гарантирует её целостность на момент выполнения некоторой транзакции T. Теперь эта транзакция фиксирует изменения операцией COMMIT: 
```
if (транзакция нарушает логическую целостность базы данных){
	откат изменений (ROLLBACK).
	} else {
	происходит фиксация.
}
```
И база данных всё равно в целостном состоянии.

#### Виды ограничения целостности:
1) **Немедленно проверяемые** - такие _ограничения_, _проверку_ которых _бессмысленно или даже невозможно откладывать_. При их нарушениях не производится откат транзакции, а лишь отвергается соответствующий оператор. 
2) **Откладываемые** - это _ограничения на базу данных_, а не на какие-либо отдельные операции. По умолчанию _такие ограничения проверяются при конце транзакции_, и их нарушение вызывает автоматическую замену оператора COMMIT на оператор ROLLBACK. 

#### Изолированность транзакций:


# 1.  Проектирование реляционных схем с использованием ER-диаграмм:
1 пункт (см. выше) находится в 8 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).


## Простой тип:
**Простым типом** сущности _называется_ тип сущности, не являющийся подтипом и не имеющий подтипов.

_Каждый_ **простой тип** сущности **_превращается_** в таблицу: 
- _Имя_ сущности становится _именем_ таблицы. 
- _Атрибут_ становится _столбцом_ таблицы; может выбираться более точный формат представления данных.
- _Экземпляр_ типа сущности становится _строкой_ таблицы.
- _Уникальный идентификатор_ сущности становятся _первичным ключом_ таблицы.

### Связи:
Связи _«многие к одному»_ и _«один к одному»_ становятся _внешними ключами_, т.е. образуется копия уникального идентификатора сущности на конце связи «один», и соответствующие столбцы составляют внешний ключ таблицы, соответствующей типу сущности на конце связи «многие».

Если между _двумя типами_ сущности A и B имеется _связь «один к одному»_, то соответствующий _внешний ключ_ по желанию проектировщика _может быть объявлен как в таблице A, так и в таблице B._

Чтобы _отразить_ в _определении_ таблицы _ограничение_, которое заключается в том, что _степень конца_ связи _равна единице_, соответствующий (возможно, составной) _столбец_ должен быть _дополнительно_ специфицирован _как возможный ключ_ таблицы.

Для **поддержки связи** _«многие ко многим»_ между типами сущности A и B создается _дополнительная_ таблица AB с _двумя столбцами_, один из которых содержит уникальные идентификаторы экземпляров сущности A, а другой – уникальные идентификаторы экземпляров сущности B.

_Пример_:
Обозначим через УИД(c) уникальный идентификатор экземпляра некоторого типа сущности C. Тогда, если в экземпляре связи «многие ко многим» участвуют экземпляры a1,a2,...,an типа сущности A и экземпляры b1,b2,...,bm типа сущности B, то в таблице AB должны присутствовать все строки вида <УИД(ai), УИД(bj)>, где i = 1,2,...,n;j = 1,2,...,m.


# 2.  Метод временных меток:

^ab2cab

2 пункт (см. выше) находится в 13 лекции на 44 слайде на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).

- Основная идея метода временных меток (Timestamp Ordering, TO), состоит в следующем:
	1) Если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой сериальный план, как если бы транзакция T1 была целиком выполнена до начала T2. Для этого каждой транзакции T предписывается временная метка t(T), соответствующая времени начала выполнения транзакции T. 
	2) При выполнении операции над объектом o транзакция T помечает его своими идентификатором, временной меткой и типом операции (чтение или изменение). 


## Перед выполнением операции над объектом Q транзакция T2 выполняет следующие действия:
- 
	1) Проверяет, помечен ли объект Q какой-либо транзакцией T1. Если не помечен, то помечает этот объект своей временной меткой и типом операции и выполняет операцию.
	2) Иначе (если Q помечен T1) транзакция T2 проверяет, не завершилась ли транзакция T1, пометившая этот объект. Если транзакция T1 закончилась, то T2 помечает объект Q и выполняет свою операцию.
	3) Иначе (если T1 не завершилась) T2 проверяет конфликтность операций. Если операции неконфликтны, то при объекте Q запоминается идентификатор транзакции T2, остается или проставляется временная метка с меньшим значением, и транзакция T2 выполняет свою операцию.
	4) Иначе (если операции транзакций T2 и T1 конфликтуют), то если t(T2) > t(T1) (т.е. транзакция T1 «моложе» T2), то производится откат T1 и всех других транзакций, идентификаторы которых сохранены при объекте Q, и T2 выполняет свою операцию.
	5) Если же t(T2) ≤ t(T1) (T1 «старше» T2), то производится откат T2, и T2 получает новую временную метку и начинается заново.

 - **К недостаткам метода TO относятся потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а построение графа ожидания в распределенных системах стоит очень дорого.**

# 1.  Диаграммы классов языка UML:
1 пункт (см. выше) находится в "9-2" лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8)

## UML это:
**UML** (Unified Modeling Language) - это язык _объектно ориентированного моделирования_

## UML состоит из:
**UML** _состоит_ из _подъязыков_, пример - подъязык диаграмм классов. Эти _подъязыки называются_ _метамоделями_.

## UML диаграмма классов:
**Диаграмма классов** (в терминологии UML) - это _диаграмма_, на которой показан _набор классов_ (и некоторых других сущностей, не имеющих явного отношения к проектированию БД), а _также_ _связей_ между этими классами. 
Диаграмма классов может _включать_ _комментарии_ и _ограничения_.

### Связи:
В диаграмме классов могут участвовать связи трёх категорий: 
- _зависимость_ (dependency) - это _связь_, показывающая, что _изменение_ в описании одного класса может _повлиять_ на _поведение_ _другого_ класса, использующего первый класс.
	   Как правило зависимость отражает тот факт, что в сигнатуре операции одного класса параметром является объект другого класса.
- _обобщение_ (generalization) - это _связь_ между _родителем_ (суперклассом) и _потомком_  (подклассом(наследование как в проге)).
- _ассоциация_ (association) - это _структурная связь_, показывающая, что _объекты одного_ класса некоторым образом _связаны_ с объектами _другого_ или _того же_ самого класса. 
	  В ассоциации могут связываться два класса, и тогда она называется **бинарной**. Но допускается также создание ассоциаций, связывающих сразу n классов.	 _Ассоциация_ между двумя классами называется  **агрегатной**, если имеет специальный _вид «часть-целое»_.
	  Если _уничтожение_ _«целого»_ приводит к _уничтожению всех_ его _«частей»_, агрегатные ассоциации называются **композитными**


## Кратность:
**Кратность роли ассоциации** - это _характеристика_, указывающая, _сколько_ объектов класса с _данной ролью_ должно _участвовать_ в _каждом_ _экземпляре_ ассоциации. 
__Кратность__ роли ассоциации _задаётся_ указанием _конкретного_ _числа_ или _диапазона_ рядом с _концом_ связи.


## Класс:
**Класс** - это именованное _описание_ совокупности _объектов с общими атрибутами_, операциями, связями и семантикой.

**Атрибут класса** - это именованное _свойство_ класса, _описывающее_ множество _значений_, которые могут _принимать_ _экземпляры_ этого свойства. 

**Множество атрибутов класса** описывает _структуру_ этого класса.

**Операция класса** - это именованная _услуга_, которую можно _запросить_ у любого _объекта_ этого класса. 

**Операция** – это то, что можно _делать_ с _объектом_. Класс может содержать любое число операций (в частности, ни одной). 
Набор операций класса является общим для всех объектов данного класса.


# 2.  Оптимизации поиска оптимального плана запроса:

**Оптимизация запросов** – это _процесс_ выбора наиболее _эффективного_ **плана** из одной или многих _стратегий_, которые могут быть применены для _обработки запросов_.

**План поиска** **оптимизации**:
1. Получение эквивалентных планов запроса.
2. По каждому логическому запросу сгенерировать всевозможные физические планы запросов. 
3. Для каждого плана посчитать стоимость, выбрать наименьший.

**Возможные оптимизации**:
1) Оптимизация на уровне _реляционной алгебры_, когда система пытается найти выражение, которое эквивалентно указанному выражению, но наиболее эффективно для вычисления.
2) _Выбор_ детализированной _стратегии_ для _обработки запроса_, такой как выбор алгоритма для выполнения операции.
3) Использование _указателей_ на подмножества планов.
4) _Уменьшение_ количества генерируемых _планов_ запроса (на основе _эвристик_ и стат. данных) 
	   используется информация из системного каталога (INFORMATION_SCHEMA)
5) _Разделение_ ответсвенности ("разделяй и властвуй для физ. планов")
6) _Кэширование_ планов


# Обработка запросов(Лекции 10-13)
## 1) Обработка запросов. Преобразование SQL-выражения во внутреннее представление СУБД.
-   Обзор     
-   Меры стоимости запросов
-   Операция выборки
-   Сортировка
-   Операция соединения
-   Другие операции 
-   Вычисления выражений
## Основные шаги обработки: 
1. Парсинг и трансляция
2. Оптимизация
3. Вычисление
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/1.png)
### Парсинг и трансляция
-   Осуществляется трансляция запроса в его внутреннюю форму. Затем осуществляется трансляция в реляционную алгебру.
-   Парсер осуществляет проверку синтаксиса и проверку отношений
### Вычисление
-   Механизм выполнения запросов принимает на вход план запросов, выполняет данный план, и возвращает ответ для запроса.
### Оптимизация
- Выражения реляционной алгебры могу иметь эквивалентные выражения
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/2.png)
-   Каждая операция реляционной алгебры может быть вычислена разными алгоритмами
-   Связанное выражение, уточняющее детальную стратегию выполнения называется планом вычислений (evaluation-plan)
	-   Используется индекс на salary, чтобы найти всех преподавателей с зп < 75000,
	-   Или производится полный скан(обход) отношения и убирает инструкторов с зп ≥ 75000
-   ***Оптимизация запросов***: Из всех эквивалентных планов выполнения выбирается с меньшей стоимостью. 
	-   Стоимость вычисляется с использованием статистической информации из каталога базы данных. 
		-   Например, число кортежей в каждом отношении, размер кортежей и т.д.   
# 2) Версионные методы управления транзакциями.
-   Основная идея версионных алгоритмов сериализации транзакций состоит в том, что в базе данных допускается существование нескольких «версий» одного и того же объекта.     
-   Эти алгоритмы, главным образом, направлены на преодоление конфликтов транзакций категорий R/W и W/R, позволяя выполнять операции чтения над некоторой предыдущей версией объекта базы данных. 
-   В результате операции чтения выполняются без задержек и тупиков, свойственных механизмам синхронизационных блокировок, а также без некоторых откатов, возможных при применении метода временных меток.**
### Версионный вариант метода временных меток
```
Транзакция - это последовательность операций над БД, рассматриваемых СУБД как единое целое: либо все операции внутри транзакции выполняются, либо ни одна не выполняется. 
Транзакция в SQL – это несколько последовательных инструкций SQL, которые вместе образуют логическую единицу работы (unit of work).
```
-   Multiversion Timestamp Ordering, `MVTO`
-   Порядок выполнения операций одновременно выполняемых транзакций задается порядком временных меток, которые получают транзакции во время старта.
-   Временные метки также используются для идентификации версий данных при чтении и модификации – каждая версия получает временную метку той транзакции, которая её записала.
-   Алгоритм не только следит за порядком выполнения операций транзакций, но также отвечает за преобразование операций над объектами базы данных в операции над версиями этих объектов, т.е. каждая операция над объектом базы данных o преобразуется в соответствующую операцию над некоторой версией объекта _o_.
Алгоритм `MVTO` работает следующим образом:

```Ri, Rj, Ti, Tk, Wi, oi, ok - i, j, k являются нижними индексами```
1.  Любая операция R_i(o) преобразуется в операцию R_i(ok), где ok – это версия объекта o, помеченная наибольшей временной меткой t(T_k), такой что t(T_k) ≤ t(T_i).
2.  Операция Wi(o) обрабатывается следующим образом:
 -   Если уже обработана операция Rj(ok), такая что t(Tk) ≤ t(Ti) < t(Tj), то операция W_i(o) отменяется, а транзакция T_i откатывается.
-   В противном случае Wi(o) преобразуется в W_i(oi).
3.  Завершение (`COMMIT`) любой транзакции T откладывается до завершения всех транзакций, записавших версии объектов, которые прочитала T.
-   При откате любой транзакции уничтожаются все созданные ею версии объектов базы данных и откатываются все транзакции, прочитавшие хотя бы одну из этих версий («каскадные» откаты).
-   Основные преимущества алгоритма `MVTO` - это отсутствие задержек и откатов при выполнении операций чтения, а основной недостаток – возможность возникновения каскадных откатов транзакций при выполнении операций записи. 
-   Кроме того, в базе данных может накапливаться произвольное число версий одного и того же объекта, и определение того, какие версии больше не требуются, является серьезной технической проблемой.

### Версионный вариант протокола 2PL
-   Two-Version Two-Phase Locking Protocol, `2V2PL`
-   Поддерживается до двух версий объектов базы данных
-   Текущей версией объекта базы данных будем называть версию, созданную зафиксированной транзакцией с наиболее поздним временем фиксации. Незафиксированной версией объекта БД – версию, созданную еще незавершившейся транзакцией. 
-   В соответствии с протоколом `2V2PL`, в каждый момент времени существует не более одной незафиксированной версии каждого объекта базы данных.
#### Операции любой транзакции Ti над объектом базы данных o обрабатываются следующим образом:
```Ri, Rj, Ti, Tk, Wi, oi, ok - i, j, k являются нижними индексами```
1.  Операция Ri(o) немедленно выполняется над текущей версией объекта o
2.  Операция Wi(o), приводящая к созданию новой версии объекта o, выполняется только после завершения транзакции, создавшей незафиксированную версию объекта o
3.  Выполнение операции `COMMIT` откладывается до тех пор, пока не завершатся все транзакции Tk, прочитавшие текущие версии объектов базы данных, которые должны замениться незафиксированными версиями этих объектов, созданными транзакцией Ti

#### Для реализации такого поведения используются специальные виды синхронизационных блокировок:
-   `RL (Read Lock)` – в этом режиме блокируется любой объект базы данных o перед выполнением операции чтения его текущей версии. Удержание этой блокировки до конца транзакции гарантирует, что при повторном чтении объекта o будет прочитана та же версия этого объекта.
-   `WL (Write Lock)` – в этом режиме блокируется любой объект базы данных o перед выполнением операции, приводящей к созданию новой (незафиксированной) версии этого объекта. Удержание этой блокировки до конца транзакции гарантирует, что в любой момент времени будет существовать не более одной незафиксированной версии любого объекта базы данных.
-   `CL (Commit Lock)` – блокировка устанавливается во время выполнения операции `COMMIT` транзакции и затрагивает любой объект базы данных, новую версию которого создала данная транзакция. Удовлетворение этой блокировки для данной транзакции гарантирует, что завершились все транзакции, читавшие текущие версии объектов, новые версии которых были созданы при выполнении данной транзакции, и, следовательно, их можно заменить.
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/3.png)
### Версионно-блокировочный протокол сериализации транзакций для поддержки только читающих транзакций
-   Multiversion Protocol for Read-Only Transactions, `ROMV`
-   Гибридный протокол, поддерживающий эффективное выполнение транзакций, не изменяющих состояние базы данных
-   При применении этого протокола при образовании каждой транзакции явно указывается её тип – только читающая (read-only) или изменяющая (update) транзакция. В только читающих транзакциях допускается использование только операций чтения объектов базы данных, а в изменяющих транзакциях – операций и чтения, и записи.
### Romv
-   Изменяющие транзакции выполняются в соответствии с обычным протоколом `2PL`, т.е. перед выполнением операции над объектом базы данных o этот объект должен быть заблокирован до конца изменяющей транзакции. Каждая операции записи объекта o создает его новую версию, которая при завершении транзакции помечается временной меткой, соответствующей моменту фиксации этой транзакции.
-   Каждая только читающая транзакция при своем образовании получает соответствующую временную метку. При выполнении операции чтения объекта базы данных o транзакция получает доступ к версии объекта o, образованной изменяющей транзакцией, которая хронологически последней зафиксировалась к моменту образования данной читающей транзакции.
-   Основным плюсом по сравнению с протоколом `2V2PL` является принципиальное отсутствие синхронизационных задержек при выполнении операций чтения только читающих транзакций.     
-   В сравнении с `MVTO`, `ROMV` выигрывает в принципиальном отсутствии откатов только читающих транзакций. 
-   При использовании протокола `ROMV` в базе данных может возникать произвольное число версий объектов. Требуется создание специального сборщика мусора, который должен удалять ненужные версии данных.

# Меры стоимости запросов(лекции 10 - ?)
**Меры стоимости запроса**
-   Многие факторы участвуют при оценке времени
-   Доступ к диску, CPU, и сетевые коммуникации
-   Стоимость может быть вычислена на основе
-   времени ответа, т.е. общее время ответа на запросы
-   общее потребление ресурсов
-   Будет рассматривать метрику по потреблению ресурсов
-   Время ответа сложнее вычислить, уменьшение потребления ресурсов – хорошая метрика в общей (shared) БД
-   Мы игнорируем стоимость CPU для простоты
-   Реальные системы используют стоимость CPU для оценки
-   Стоимость сети рассматривается для параллельных систем
-   Опишем, как вычислить стоимость для каждой операции
-   Стоимость записи на диск игнорируем для простоты

-   Стоимость доступа на диск может быть рассчитана как:
	-   Число поисков                *  среднее время поиска 
	-   Число блоков чтения     *  среднее время чтения блока
	-   Число блоков записи     *  среднее время записи блока
-   Для простоты учитываем число трансфера блока с диска  и число поисков как меры стоимости
	-   tₜ – время для трансфера одного блока
		-   Для простоты предполагаем, что стоимость записи соответствует  стоимости чтения
	-   tₛ – время для одного поиска
	-   Стоимость для b трансферов блоков и S поисков b * tₜ + S * tₛ 
-   tS и tₜ зависят от того, где хранятся данные; с 4 KB блоками:
-   HDD: tₛ = 4 msec и tₜ =0.1 msec
-   SSD: : tₛ = 20-90 microsec и tₜ = 2-10 microsec для  4KB
-   Требуемые данные могут быть уже в буфере и, следовательно, не потребуется I/O
	-   Но это сложно учитывать при оценке
-   Часть алгоритмов может уменьшать дисковое IO, если есть дополнительное место в буфере
	-   Количество реально доступной памяти в буфере зависит от параллельных запросов и процессов ОС в момент выполнения
-   Худший вариант предполагает, что изначально нет данных в буфере и только минимальное количество памяти может быть выделено для операции
	-   Более оптимистичные сценарии обычно предполагают наличие места
## Операция выборки
-   **Скан (обход) файла**
-   Алгоритм A1 (линейный поиск). Обходит каждый блок файла и тестирует все записи на условие отбора.
	-   Стоимость выполнения= br трансферов блока + 1 поиск
		-   bᵣ  определяет число блоков записей в отношении r
	-   Если выборка по ключевом атрибуте, то можно остановиться при нахождении
		-   Стоимость = (bᵣ /2) трансферов блока + 1 поиск
	-   Линейный поиск может применяться независимо от 
		-   Условия выборки
		-   Сортировки записей в файле
		-   Доступности индексов
-   Замечание: для бинарного поиск обычно нет смысла, так как данные не хранятся последовательно
	-   И бинарный поиск требует большее число поисков
## Выборка при использовании индексов
-   **Обход индекса** – алгоритмы поиска, использующие индекс 
	-   Условие выборки должно содержать ключ поиска в индексе.
-   **A2 (кластерный индекс, равенство по ключу)**. Вывод: одна запись, которая подходит по равенству по ключу
	-   Стоимость = (hᵢ + 1) * (tₜ + tₛ)
-   **A3 (кластерный индекс, равенство не по ключу)**. Вывод: несколько записей. 
	-   Записи должны быть на последовательных блоках
		-   Пусть b = число блоков, содержащих совпадающие записи
	-   Стоимость= hᵢ * (tₜ + tₛ) + tₛ + tₜ * b
-   **A4 (вторичный индекс, равенство (не) по ключу).**
	-   Возвращает одну запись, если ключ поиска уникален
		-   Стоимость= (hᵢ + 1) * (tₜ + tₛ)
	-   Возвращает несколько записей, если ключ поиска м.б. не уникален
		-   Каждая из n совпадающих записей может быть в разных блоках
		-   Стоимость =  (hᵢ + n) * (tₜ + tₛ) 
			-   Может быть очень дорогой операцией
## Выборки, включающие сравнения
```
1) ≥,≤ - subscript(нижний индекс)
```
-   Можно разработать выборки формы σₐ≤ᵥ(r) или σₐ≥ᵥ(r) через
	-    линейный обход файла,
	-    использование индексов следующими способами
-   **A5 (кластерный индекс, сравнение)**. (Отношение отсортировано по A)
	-   Для σₐ≥ᵥ(r)  используется индекс для нахождения первого кортежа ≥ v  и 	далее последовательный обход отношения
	-   Для σₐ≤ᵥ(r) просто последовательный обход отношения до момента, как кортеж> v;**
-   Можно разработать выборки формы σₐ≤ᵥ(r) или σₐ≥ᵥ(r) через
	-    линейный обход файла,
	-    использование индексов следующими способами
-   **A6 (кластерный индекс, сравнение)**. 
	-   Для σₐ≥ᵥ(r)  используется индекс для нахождения первой записи ≥ v  и осуществлять последовательный поиск для нахождения указателя на записи
	-   Для σₐ≤ᵥ(r) обходить корневые страницы до условия > v
	-   Если условие не соответствует порядку А, то может потребоваться одно чтение на запись

```
1) θ - subscript(нижний индекс)
```

## Реализация сложных выборок
```
1) θ - subscript(нижний индекс)
```
-   Конъюнкция:  σθ₁∧θ₂∧. . . ₔₙ(r)  
-  **A7 (конъюнктивная выборка с использованием одиночного индекса) **.  
	-   Все условия по индексу проверяем
	-   Остальные проверки в буфере памяти
-    **A8 (конъктивная выборка с использованием сложного индекса **.  
	-   Используется подходящий сложный составной индекс.
-    **A9 (конъюнктивная выборка с пересечением идентификаторов) **. 
	-   Пересекаем указатели, подходящие для индексов
	-   Остальные проверки в памяти
## Алгоритмы для сложных выборок
```
1) θ - subscript(нижний индекс)
2) ¬ - subscript(нижний индекс)
```
-   **Дизъюнкция:**σ`θ`₁∨`θ`₂ ∨. . . `θ`ₙ(r). 
-   **A10 (дизъюнктивная выборка по объединению идентификаторов)**. 
	-   Применима, если все условия имеют индексы
		-   В другом случае линейный поиск
-   **Отрицание:**  σ`¬θ`(r)
	-   Линейный поиск по файлу
	-   Если не много записей `¬θ`, и индекс применим по `θ`
		-    Найти подходящие записи по индексу
## Сортировка
-   Можно построить индекс по отношению, и использовать индекс для чтения в том же порядке. Для каждого кортежа может потребоваться только одно чтение.
-   Для отношений, помещающихся в памяти, можно использовать стандартные сортировки, например quicksort. Для не помещающихся  external sort-merge.
## Стоимость сортировки
```
1) θ - subscript(нижний индекс)
```
Пусть bᵣ - число блоков в отношение r. Первая стадия – чтение каждого блока отношения и его перезапись - 2bᵣ. Изначальное число пробегов - bᵣ/M
Для эффективного слияния требуется b`b` буферных блоков для каждого входа пробега и его выхода.

*images here*
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/sort_image1.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/sort_image2.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/nested_loops.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/block_sort.png)

![merge](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/merge.png)

![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/hash_join.png)
## Транзакции
#### Различаются два вида ограничений целостности: немедленно проверяемые и откладываемые.
-   К немедленно проверяемым ограничениям целостности относятся такие ограничения, проверку которых бессмысленно или даже невозможно откладывать. При их нарушениях не производится откат транзакции, а лишь отвергается соответствующий оператор. 
-   Откладываемые ограничения целостности – это ограничения на базу данных, а не на какие-либо отдельные операции. По умолчанию такие ограничения проверяются при конце транзакции, и их нарушение вызывает автоматическую замену оператора COMMIT на оператор ROLLBACK.

# Меры стоимости запросов
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/nested_loops.png)
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/block_sort.png)
![merge](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/merge.png)
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/hash_join.png)

## Изолированность транзакций
-   В многопользовательских системах с одной базой данных одновременно может работать несколько пользователей или прикладных программ. Предельной задачей системы является обеспечение изолированности пользователей (приложений), т.е. создание достоверной и надежной иллюзии того, что каждый из пользователей работает с базой данных в одиночку. 
-   В связи со свойством сохранения целостности базы данных транзакции являются подходящими единицами изолированности пользователей.

# 1. Вычисление SQL-выражений. Материализация.
1) Для вычисления выражений, содержащих несколько реляционных операций, существует несколько вариантов вычисления. Если каждая операция вычисляется отдельно и результатом такого шага является временное отношение, то такая ситуация называется материализацией. Альтернативным способом является организация конвейра (pipeline) выполнения параллельных операций.

2) Материализация. Материализованное вычисление представляет собой последовательность вычислений, в которой создается каждая промежуточная операция (материализуется) и используется для вычислений дальнейших шагов. Для вычисления стоимости требуется добавить стоимость всех операций и стоимости записи временных результатов на диск. Одним из вариантов оптимизаций является двойная буферизация (один из буферов осуществляет вычисление, а другой - запись)

##### 2. Синхронизационные тупики, их распознавание и разрушение.
1) Независимо от вида протокола 2PL, всем методам блокировочных протоколов свойствена возмодность возникновения тупиков (deadlocks) между транзакциями.

Снизу показан простой сценарий возникновения синхронизационного тупика между транзакциями T1 и T2. Такой ориентированный граф называется _графом ожидания транзакций_. Циклы в таком графе обозначает синхронизационный тупик. Такие ситуации необходимо обнаруживать и искусственно устранять.
![[./images/Pasted image 20220702130129.png]]

2) Основой обнаружения тупиковых ситуаций является построение или постоянное поддерживание графа ожидания транзакций. Граф ожидания транзакций - это двудольный ориентированный граф, вершины которого соответствуют либо транзакциям, либо объектам блокировок.

3) Разрушение тупиков. Нужно каким-то образом обеспечить воможность продолжения работы хотя бы для части транзакций, попавших в тупик. Разрушение тупика начинается с выбора в цикле транзакции-жертвы, т.е. транзакции, которой решено пожертвовать, чтобы обеспечить возмодность продолжения работы других транзакций. Для этого могут использоваться различные, зачастую противоречивые критерии: транзакция, которая удерживает наибольшее число блокировок объектов; транзакция, которая существует в системе в течение наименьшего времени; можно выбрать транзакцию-жертву случайным образом. Обычно при выборе транзакции-жертвы используется многофакторная офенка её стоимости, в которую с разными весами входят время выполнения, число накопленных блокировок, приоритет и т.д. В качестве "жертвы" выбирается транзакция, для которой эта оценка выдает наиболее подходящий результат. После выбора транзакции-жертвы выполняется откат этой транзакции, который может носить полный или частичный (до некоторой точки сохранения) характер. При этом, естественно, освобождаются блокировки, и может быть продолжено выполнение других транзакций.


# 1. Вычисление SQL-выражений. Конвейер.

##### Вычисление выражений.
- Вычисление выражений, содержащих несколько реляционных операций, существует несколько вариантов вычисления. Если каждая операция вычисляется отдельно и результатом такого шага является временное отношение, то такая ситуация называется материализацией. Альтернативным способом является организация конвейра (pipeline) выполнения параллельных операций.

##### Конвейер. 
- Уменьшает стоимость чтения и записи временных отношений. Довольно быстрый отклик в передаче результатов запроса, если план запроса позволяет полноценный конвейер.
###### Конвейер бывает 2х типов:
1) Demand-driven (Ленивое вычисление). Demand-driven - результат запроса операций низкого уровня не передается автоматически на более высокий уровень. Он будет передан, когда будет осуществлен запрос более высокого уровня.
2) Producer-driven (Жадное вычисление). Producer-driven - операции не ждут запрос для вычисления кортежей. Каждая операция в producer-driven конвейере моделируется как отдельный процесс или поток в системе, которая на вход принимает поток кортежей и на выходе также поток кортежей.


##### Реализация конвейера вычислений.
1) Каждая операция в ленивом конвейере может быть разработана как итератор, который предоставляет следующие функции: open(), next(), close().
2) После вызова open(), каждое обращение к next() возвращает следующий кортеж на выход операции. 
3) Функция close() сообщает итератору, что больше кортежей не требуется.
4) Итератор хранит состояние вычисления между вызовами. Конвейеры с жадным вычислением реализованы другим образом.
5) Для каждой смежной пары операций в конвейере, система создает буфер для фиксации кортежей, передающиеся с одной операции на другую.
6) Процессы (или потоки) разных операций работаю параллельно. Каждая операция внизу кортежа последовательно вычисляет кортежи для вывода, и передает его в буфер вывода, до момента переполнения буфера.
7) Как только операция использует кортеж из входного буфера, он удаляется из буфера.
8) Если буфер вывода полный, то операция ожидает забор данных из буфера более высокоуровневой операцией. Существует возможность распараллеливания операций внутри конвейера в случае многопроцессорных систем.

# 2. Нормализация БД.
- Цель нормализации: исключить избыточное дублирование данных, которое является причиной [[#^f89791|аномалий]], возникших при добавлении, редактировании и удалении кортежей (строк таблицы).
- Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).
- Метод нормальных форм (НФ) состоит в сборе информации о объектах решения задачи в рамках одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений.

##### 1НФ:
- Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

##### 2НФ:
- Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа (ПК). Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

##### 3НФ:
- Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.

###### Нормальная форма Бойса-Кодда (НФБК):
- Определение 3НФ не совсем подходит для следующих отношений:
1) отношение имеет два или более потенциальных ключа;
2) два и более потенциальных ключа являются составными;
3) они пересекаются, т.е. имеют хотя бы один общий атрибут.
- Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ.
- Отношение находится в НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает потенциальным ключом в качестве детерминанта.
- Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.

##### 4НФ:
- Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей. В отношении R (A, B, C) существует многозначная зависимость R.A->R.B в том и только в том случае, если множество значений B, соответствующее паре значений A и C, зависит только от A и не зависит от С.

##### 5НФ:
- Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами. Если «Атрибут_1» зависит от «Атрибута_2», а «Атрибут_2» в свою очередь зависит от «Атрибута_3», а «Атрибут_3» зависит от «Атрибута_1», то все три атрибута обязательно входят в один кортеж.

###### Доменно-ключевая нормальная форма (ДКНФ):
- Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.
- Ограничение домена – ограничение, предписывающее использовать для определённого атрибута значения только из некоторого заданного домена. Ограничение по своей сути является заданием перечня (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип.
- Ограничение ключа – ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является потенциальным ключом.
- Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную отношения можно привести к ДКНФ.

##### 6НФ:
- Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. 


# 1. Оптимизация запросов.
##### Что это:

1) Оптимизация запросов – процесс выбора наиболее эффективного плана из одной или многих стратегий, которые могут быть применены для обработки запросов.
2) Один из пунктов оптимизации возникает на уровне реляционной алгебры, когда система пытается найти выражение, которое эквивалентно указанному выражению, но наиболее эффективно для вычисления.
3) Другой пункт оптимизации – это выбор детализированной стратегии для обработки запроса, такой как выбор алгоритма для выполнения операции.

##### Общий план поиска.
1) Для каждого плана посчитать стоимость, выбрать наименьший.
Берете план запроса и делаете цикл:
```
для каждого нового элемента
	для каждого правила
		пытаемся создать выражение на основе правила эквивалентности
		если выражение новое, добавляем в список
```
2) Получение всевозможных эквивалентных планов запроса.
3) По каждому логическому запросу сгенерировать всевозможные физические планы запросов.

##### Возможные оптимизации.
- Использование указателей на подмножества планов.
- Уменьшение количества генерируемых планов запроса (на основе эвристик и стат. данных).
- используется информация из системного каталога (INFORMATION_SCHEMA).
- Разделяй и властвуй для физ. планов.
- Кэширование планов.

##### INFORMATION_SCHEMA.
- Количество кортежей в отношении - n(r).
- Количество блоков, содержащих кортежи отношения - b(r).
- Данные об устройстве кортежа.
- Распределение количества кортежей в блоке - f(r).
- Гистограмма уникальных значений в таблице по полям.
- b(r) ≈ n(r)/f(r)


# 2. Метод временных меток.

##### Основная идея метода временных меток (Timestamp Ordering, TO), состоит в следующем:
1) Если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой сериальный план, как если бы транзакция T1 была целиком выполнена до начала T2. Для этого каждой транзакции T предписывается временная метка t(T), соответствующая времени начала выполнения транзакции T.
2) При выполнении операции над объектом o транзакция T помечает его своими идентификатором, временной меткой и типом операции (чтение или изменение).

3) Перед выполнением операции над объектом o транзакция T2 выполняет следующие действия:
4) Проверяет, помечен ли объект o какой-либо транзакцией T1. Если не помечен, то помечает этот объект своей временной меткой и типом операции и выполняет операцию.
5) Иначе (если o помечен T1) транзакция T2 проверяет, не завершилась ли транзакция T1, пометившая этот объект. Если транзакция T1 закончилась, то T2 помечает объект o и выполняет свою операцию.
6) Иначе (если T1 не завершилась) T2 проверяет конфликтность операций. Если операции неконфликтны, то при объекте o запоминается идентификатор транзакции T2, остается или проставляется временная метка с меньшим значением, и транзакция T2 выполняет свою операцию.

7) Иначе (если операции транзакций T2 и T1 конфликтуют), то если t(T2) > t(T1) (т.е. транзакция T1 «моложе» T2), то производится откат T1 и всех других транзакций, идентификаторы которых сохранены при объекте o, и T2 выполняет свою операцию.
8) Если же t(T2) ≤ t(T1) (T1 «старше» T2), то производится откат T2, и T2 получает новую временную метку и начинается заново.
##### К недостаткам метода TO относятся:
- Потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а построение графа ожидания в распределенных системах стоит очень дорого.



# 1. Транзакции: ACID-тест, многопользовательский режим, блокировки (лк 13).
Транзакция - это последовательность операций над БД, рассматриваемых СУБД как единое целое: либо все операции внутри транзакции выполняются, либо ни одна не выполняется. 
Транзакция в SQL – это несколько последовательных инструкций SQL, которые вместе образуют логическую единицу работы (unit of work).
В современных СУБД поддерживается понятие транзакции, характеризуемое аббревиатурой ACID:
*	Atomic (атомарность)
*	Consistent (целостность)
*	Isolation (изолированность)
*	Durability (долговечность)
### Атомарность:
*	Означает, что результаты всех операций, успешно выполненных в пределах транзакции, должны быть отражены в состоянии базы данных, либо в состоянии базы данных не должно быть отражено действие ни одной операции. 
*	Свойство атомарности, которое часто называют свойством “все или ничего”, позволяет относиться к транзакции, как к динамически образуемой составной операции над базой данных. В общем случае состав и порядок выполнения операций, выполняемых внутри транзакции, становится известным только на стадии выполнения.
Целостность(Согласованность): 
*	Означает, что транзакция может быть успешно завершена с фиксацией результатов своих операций только в том случае, когда действия операций не нарушают целостность базы данных, т.е. удовлетворяют набору ограничений целостности, определенных для этой базы данных. 
*	Это свойство расширяется тем, что во время выполнения транзакции разрешается устанавливать точки согласованности и явным образом проверять ограничения целостности. 
Изолированность: 
*	Требуется, чтобы две одновременно выполняемые транзакции никаким образом не действовали одна на другую. 
*	Результаты выполнения операций транзакции T1 не должны быть видны никакой другой транзакции T2 до тех пор, пока транзакция T1 не завершится успешным образом.
Долговечность: 
*	После успешного завершения транзакции, все изменения, которые были внесены в состояние базы данных операциями этой транзакции, должны гарантированно сохраняться, даже в случае сбоев аппаратуры или программного обеспечения.

# Алгоритм Hash Join (лк 10).
## Hash Join алгоритм:
  1. Разбить отношение S на секции.
  2. Разбить отношение r на секции
  3. Для каждого i
        1. Загрузить S_i в памяти и построить хэш индекс в памяти
        2. Считывать кортежи в r\_i по одному. Для каждого кортежа t\_r найти совпадающий кортэж t_s в s. Вывести конкатенацию
## Hash Join стоимость
    3(b\_r+b\_s)+4n_h переносов
    2(b\_r/b\_b  + b\_s/b_b) поисков


# Средства журнализации и восстановления баз данных (лк 14).
Очевидно, что для выполнения восстановлений необходима некоторая дополнительная информация. В подавляющем большинстве современных реляционных СУБД такая избыточная дополнительная информация поддерживается в виде журнала изменений базы данных.
Общей целью журнализации изменений баз данных является обеспечение возможности восстановления согласованного состояния базы данных после любого сбоя. Общими принципами восстановления являются следующие:
*	Результаты зафиксированных транзакций должны быть сохранены в восстановленном состоянии базы данных, т.е. должно поддерживаться свойство долговечности (durability) транзакций.
*	Результаты незафиксированных транзакций должны отсутствовать в восстановленном состоянии базы данных, в противном случае состояние базы данных могло бы оказаться не целостным.

## Журнал

### Есть несколько способов ведения журнала:
*	Поддержка отдельного локального журнала изменений базы данных для каждой транзакции. Эти локальные журналы используются для индивидуальных откатов транзакций и могут поддерживаться в оперативной памяти СУБД. Кроме того, поддерживается общий журнал изменений базы данных, используемый для восстановления состояния базы данных после мягких и жёстких сбоев. 
*	Поддержка только общего журнала изменений базы данных, который используется и для индивидуальных откатов, и для восстановления после мягкого и жёстких сбоев. 

###Протокол записи в журнал 

Основным принципом согласованной политики выталкивания буфера журнала и буферных страниц базы данных является то, что запись об изменении объекта базы данных должна оказаться во внешней памяти журнала раньше, чем изменённый объект окажется во внешней памяти базы данных. 
Соответствующий протокол журнализации называется WAL (Write Ahead Log) и состоит в том, что если требуется вытолкнуть во внешнюю память буферную страницу, содержащую изменённый объект базы данных, то перед этим нужно гарантировать выталкивание во внешнюю память журнала буферной страницы журнала, содержащей запись об изменении этого объекта.
### Индивидуальный откат транзакции 
Выполняется следующим образом:
*	Выбирается очередная журнальная запись из списка записей данной транзакции.
*	Выполняется противоположная по смыслу операция:
*	вместо операции INSERT выполняется соответствующая операция DELETE
*	вместо операции DELETE выполняется INSERT
*	вместо прямой операции UPDATE – обратная операция UPDATE, восстанавливающая предыдущее состояние объекта базы данных

Эти обратные операции называются undo, и они тоже журнализуются.
Если полный откат транзакции выполнен успешно, то в журнал заносится запись о конце транзакции, и с точки зрения журнала такая транзакция является зафиксированной.
### Журнал изменений
*	Логический журнал должен поддерживать как обратное выполнение журнализованных операций (undo), так и их повторное прямое выполнение (redo). От физического журнала требуется только поддержка обратного выполнения постраничных операций.
*	Логический журнал обычно начинает заполняться заново только после выполнения операций резервного копирования базы данных или архивирования самого журнала. До этого времени он линейно растет. В отличие от этого, физический журнал существует сравнительно недолгое время - интервал времени между соседними точками физической согласованности БД. 

# Алгоритм Merge Join (лк 10).
Алгоритм соединения слиянием сортированных списков — разновидность алгоритма соединения.
Алгоритм получает на вход две таблицы и условие соединения. Результатом его работы является таблица с результатами соединения.
Входные таблицы должны быть отсортированы по столбцам, участвующим в условии соединения. Соединение осуществляется за одно сканирование (проход по) каждой из входных таблиц. То есть одна и та же строка считывается только один раз, что даёт преимущество перед соединением вложенными циклами.


