# 1.  Проектирование реляционных схем с использованием ER-диаграмм:
1 пункт (см. выше) находится в 8 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).


## Простой тип:
**Простым типом** сущности _называется_ тип сущности, не являющийся подтипом и не имеющий подтипов.

_Каждый_ **простой тип** сущности **_превращается_** в таблицу: 
- _Имя_ сущности становится _именем_ таблицы. 
- _Атрибут_ становится _столбцом_ таблицы; может выбираться более точный формат представления данных.
- _Экземпляр_ типа сущности становится _строкой_ таблицы.
- _Уникальный идентификатор_ сущности становятся _первичным ключом_ таблицы.

### Связи:
Связи _«многие к одному»_ и _«один к одному»_ становятся _внешними ключами_, т.е. образуется копия уникального идентификатора сущности на конце связи «один», и соответствующие столбцы составляют внешний ключ таблицы, соответствующей типу сущности на конце связи «многие».

Если между _двумя типами_ сущности A и B имеется _связь «один к одному»_, то соответствующий _внешний ключ_ по желанию проектировщика _может быть объявлен как в таблице A, так и в таблице B._

Чтобы _отразить_ в _определении_ таблицы _ограничение_, которое заключается в том, что _степень конца_ связи _равна единице_, соответствующий (возможно, составной) _столбец_ должен быть _дополнительно_ специфицирован _как возможный ключ_ таблицы.

Для **поддержки связи** _«многие ко многим»_ между типами сущности A и B создается _дополнительная_ таблица AB с _двумя столбцами_, один из которых содержит уникальные идентификаторы экземпляров сущности A, а другой – уникальные идентификаторы экземпляров сущности B.

_Пример_:
Обозначим через УИД(c) уникальный идентификатор экземпляра некоторого типа сущности C. Тогда, если в экземпляре связи «многие ко многим» участвуют экземпляры a1,a2,...,an типа сущности A и экземпляры b1,b2,...,bm типа сущности B, то в таблице AB должны присутствовать все строки вида <УИД(ai), УИД(bj)>, где i = 1,2,...,n;j = 1,2,...,m.


# 2.  Метод временных меток:

^ab2cab

2 пункт (см. выше) находится в 13 лекции на 44 слайде на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).

- Основная идея метода временных меток (Timestamp Ordering, TO), состоит в следующем:
	1) Если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой сериальный план, как если бы транзакция T1 была целиком выполнена до начала T2. Для этого каждой транзакции T предписывается временная метка t(T), соответствующая времени начала выполнения транзакции T. 
	2) При выполнении операции над объектом o транзакция T помечает его своими идентификатором, временной меткой и типом операции (чтение или изменение). 


## Перед выполнением операции над объектом Q транзакция T2 выполняет следующие действия:
- 
	1) Проверяет, помечен ли объект Q какой-либо транзакцией T1. Если не помечен, то помечает этот объект своей временной меткой и типом операции и выполняет операцию.
	2) Иначе (если Q помечен T1) транзакция T2 проверяет, не завершилась ли транзакция T1, пометившая этот объект. Если транзакция T1 закончилась, то T2 помечает объект Q и выполняет свою операцию.
	3) Иначе (если T1 не завершилась) T2 проверяет конфликтность операций. Если операции неконфликтны, то при объекте Q запоминается идентификатор транзакции T2, остается или проставляется временная метка с меньшим значением, и транзакция T2 выполняет свою операцию.
	4) Иначе (если операции транзакций T2 и T1 конфликтуют), то если t(T2) > t(T1) (т.е. транзакция T1 «моложе» T2), то производится откат T1 и всех других транзакций, идентификаторы которых сохранены при объекте Q, и T2 выполняет свою операцию.
	5) Если же t(T2) ≤ t(T1) (T1 «старше» T2), то производится откат T2, и T2 получает новую временную метку и начинается заново.

 - **К недостаткам метода TO относятся потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а построение графа ожидания в распределенных системах стоит очень дорого.**