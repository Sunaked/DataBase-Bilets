# 1.  Функциональные зависимости и нормальные формы:
1 пункт (см. выше) находится в 9 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).
### Термины:
- Атрибут – свойство некоторой сущности. Часто называется полем таблицы.
- Домен атрибута – множество допустимых значений, которые может принимать атрибут.
- Кортеж – конечное множество взаимосвязанных допустимых значений атрибутов, которые вместе описывают некоторую сущность (строка таблицы).
- Отношение — конечное множество кортежей (таблица).
- Схема отношения — конечное множество атрибутов, определяющих некоторую сущность. Иными словами, это структура таблицы, состоящей из конкретного набора полей.
- Проекция — отношение, полученное из заданного путём удаления и (или) перестановки некоторых атрибутов.
- Функциональная зависимость между атрибутами (множествами атрибутов) X и Y означает, что для любого допустимого набора кортежей в данном отношении: если два кортежа совпадают по значению X, то они совпадают по значению Y. 
- Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).
- Метод нормальных форм (НФ) состоит в сборе информации об объектах решения задачи в рамках одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений.
- Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении, редактировании и удалении кортежах (строк таблицы).
- Аномалией называется такая ситуация в таблице БД, которая приводит к противоречию в БД либо существенно усложняет обработку БД. Причиной является излишнее дублирование данных в таблице, которое вызывается наличием функциональных зависимостей от не ключевых атрибутов. ![[Pasted image 20220521130310.png]]

### Функциональные зависимости
- Пусть задан экземпляр отношения r(R). Пусть α,β⊆R – множество атрибутов. Экземпляр удовлетворяет функциональной зависимости α→β, если для все пар кортежей $$t_1, t_2  $$ выполнено:

$$t_1[α]=t_2[α]⇒t_1[β]=t_2[β]$$
Функциональная зависимость α→β выполняется для схемы отношения r(R), если она выполняется для каждой функциональной зависимости.
##### Пример функциональной зависимости:
![[Pasted image 20220521124925.png]]

student_id -> name
student_id -> city
student_id -> name, city
student_id, course_name -> grade
### Нормальные формы
#### Первая нормальная форма
- Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.![[Pasted image 20220521130510.png]]
#### Вторая нормальная форма
- Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа (ПК).
- Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.
![[Pasted image 20220521130607.png]]

#### Третья нормальная форма
- Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.

![[Pasted image 20220521130644.png]]


#### Нормальная форма Бойса-Кодда (НФБК)
- Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.
- Определение 3НФ не совсем подходит для следующих отношений:
	1) отношение имеет два или более потенциальных ключей;
	2) два и более потенциальных ключей являются составными;
	3) они пересекаются, т.е. имеют хотя бы один общий атрибут.
- Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ.
##### Пример:
Из этого 
![[Pasted image 20220521130952.png]]
- следует это:
![[Pasted image 20220521131020.png]]




#### Четвертая нормальная форма
- Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей.
- В отношении R (A, B, C) существует многозначная зависимость R.A->R.B в том и только в том случае, если множество значений B, соответствующее паре значений A и C, зависит только от A и не зависит от С.
#### Пятая нормальная форма
- Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами.
- Если «Атрибут_1» зависит от «Атрибута_2», а «Атрибут_2» в свою очередь зависит от «Атрибута_3», а «Атрибут_3» зависит от «Атрибута_1», то все три атрибута обязательно входят в один кортеж.
#### Доменно-ключевая нормальная форма
- Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.
- Ограничение домена – ограничение, предписывающее использовать для определённого атрибута значения только из некоторого заданного домена. Ограничение по своей сути является заданием перечня (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип.
- Ограничение ключа – ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является потенциальным ключом.
- Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную отношения можно привести к ДКНФ.
#### Шестая нормальная форма
- Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. 
# 2.  Методы сериализации транзакций:
2 пункт (см. выше) лежит в лекции 13 [препода по БД на гугл диске](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8)

### Сериализация транзакций:
- Сериализация транзакций – это механизм одновременного выполнения транзакций T1,T2,...,Tn по некоторому сериальному плану. 
- Пусть в системе одновременно выполняется некоторое множество транзакций S = {T1,T2,...,Tn}. План выполнения набора транзакций S, в котором, вообще говоря, чередуются или реально параллельно выполняются операции разных транзакций T1,T2,...,Tn, называется сериальным, если результат совместного выполнения транзакций эквивалентен результату некоторого последовательного выполнения этих же транзакций (Ti1,Ti2,...,Tin).
### Конфликты:
- Между транзакциями T1 и T2 могут существовать следующие виды конфликтов:
	1) W/W (Write/Write) – транзакция T2 пытается изменять объект, изменённый не закончившейся транзакцией T1. Может привести к ситуации потерянных изменений.
	2) R/W (Read/Write) – транзакция T2 пытается изменять объект, прочитанный не закончившейся транзакцией T1. Может привести к возникновению ситуации неповторяющихся чтений.
	3) W/R (Write/Read) – транзакция T2 пытается читать объект, изменённый не закончившейся транзакцией T1. Может привести к возникновению ситуации «грязного» чтения.

### Методы сериализации транзакций:
1) основанный на синхронизационных блокировках объектов базы данных
2) основанный на использовании временных меток

- **Для каждого из подходов имеются две разновидности: пессимистическая и оптимистическая.**:
	1) При применении пессимистических методов, ориентированных на ситуации, когда конфликты возникают часто, конфликты распознаются и разрешаются немедленно при их возникновении. 
	2) Оптимистические методы хорошо работают, когда конфликты редки. Любая транзакция, изменяющая базу данных выполняется без синхронизации вообще, но все её результаты в базу данных не пишутся, а сохраняются в её локальной памяти (до операции COMMIT). 

- Когда отрабатывает операция COMMIT система проигрывает транзакцию заново и смотрит не было ли конфликтов при выполнении рабочей фазы транзакции. Если конфликтов не было, то все её изменения реально записываются в БД. Если конфликты обнаруживаются, то транзакция откатывается.

## синхронизационные блокировки:
- В общих чертах подход состоит в том, что перед выполнением любой операции в транзакции T над объектом базы данных Q от имени транзакции T запрашивается синхронизационная блокировка объекта Q в соответствующем режиме (в зависимости от вида операции).
- Это наиболее распространенный в централизованных СУБД подход, основанный на соблюдении двухфазного протокола синхронизационных захватов объектов баз данных (TwoPhase Locking Protocol, 2PL). 

### Основными режимами в базовом варианте 2PL являются следующие:
- S (Shared) - совместный режим, означающий совместную (по чтению) блокировку объекта. Такая блокировка требуется для операции чтения объекта.
- X (eXclusive) - монопольный режим, означающий монопольную (по записи) блокировку объекта. Требуется для выполнения операций вставки, удаления и модификации объекта.
### Блокировка объекта одной транзакцией по чтению не совместима с блокировкой другой транзакцией того же объекта по записи:
- никакая транзакция не может изменять объект, читаемый некоторой транзакцией (кроме самой этой транзакции)
- никакой транзакции нельзя читать объект, изменяемый некоторой транзакцией (кроме самой этой транзакции)
- Правила совместимости режимов: ![[Pasted image 20220521150014.png]]
### Двухфазный протокол (2PL)
- Для обеспечения сериализации транзакций синхронизационные блокировки объектов, произведённые по инициативе транзакции, можно снимать только при её завершении. Это требование порождает двухфазный протокол синхронизационных захватов – 2PL. В соответствии с этим протоколом выполнение транзакции разбивается на две фазы:
	1) первая фаза транзакции (выполнение операций над базой данных) – накопление блокировок
	2) вторая фаза (фиксация или откат) – снятие блокировок

## методы временных меток:
- Основная идея метода временных меток (Timestamp Ordering, TO), состоит в следующем:
	1) Если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой сериальный план, как если бы транзакция T1 была целиком выполнена до начала T2. Для этого каждой транзакции T предписывается временная метка t(T), соответствующая времени начала выполнения транзакции T. 
	2) При выполнении операции над объектом o транзакция T помечает его своими идентификатором, временной меткой и типом операции (чтение или изменение). 


### Перед выполнением операции над объектом Q транзакция T2 выполняет следующие действия:
- 
	1) Проверяет, помечен ли объект Q какой-либо транзакцией T1. Если не помечен, то помечает этот объект своей временной меткой и типом операции и выполняет операцию.
	2) Иначе (если Q помечен T1) транзакция T2 проверяет, не завершилась ли транзакция T1, пометившая этот объект. Если транзакция T1 закончилась, то T2 помечает объект Q и выполняет свою операцию.
	3) Иначе (если T1 не завершилась) T2 проверяет конфликтность операций. Если операции неконфликтны, то при объекте Q запоминается идентификатор транзакции T2, остается или проставляется временная метка с меньшим значением, и транзакция T2 выполняет свою операцию.
	4) Иначе (если операции транзакций T2 и T1 конфликтуют), то если t(T2) > t(T1) (т.е. транзакция T1 «моложе» T2), то производится откат T1 и всех других транзакций, идентификаторы которых сохранены при объекте Q, и T2 выполняет свою операцию.
	5) Если же t(T2) ≤ t(T1) (T1 «старше» T2), то производится откат T2, и T2 получает новую временную метку и начинается заново.

 - **К недостаткам метода TO относятся потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а построение графа ожидания в распределенных системах стоит очень дорого.**