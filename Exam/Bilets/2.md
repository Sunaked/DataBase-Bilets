# 1.  Семантическая модель Entity-Relationship, E/R-диаграммы:
1 пункт (см. выше) находится в 8 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8).

_Основными понятиями_ ER-модели являются *сущность*, *связь* и *атрибут*:

**Сущность** – это реальный или представляемый объект, информация о котором должна сохраняться и быть доступной.

**Связь** – это графически изображаемая ассоциация, устанавливаемая между двумя типами сущностей.

**Атрибут** - это деталь, которая служит для уточнения, идентификации, классификации, числовой характеристики или выражения состояния сущности.

## Сущность:
В _диаграммах_ ER-модели _сущность представляется в виде прямоугольника_, содержащего имя сущности. При этом _имя сущности – это имя типа_, а не некоторого конкретного экземпляра этого типа.

## Связь:
_Обязательный конец_ связи _изображается_ _сплошной_ линией, а _необязательный_ – _прерывистой_ линией.

В любой **связи** выделяются _два конца_, на каждом из которых указываются: 
- имя конца связи
- степень конца связи
- обязательность связи

В месте «стыковки» связи с сущностью используются: 
- **Трёхточечный** вход в прямоугольник сущности, если для этой сущности в связи могутиспользоваться много экземпляров сущности
- **Одноточечный** вход, если в связи может (или должен) участвовать только один экземпляр сущности


## Атрибут:
Имена атрибутов заносятся в прямоугольник, изображающий сущность, под именем сущности и изображаются малыми буквами.


## При построении ER-модели используются следующие принципы: 
 1) сущности на диаграмме представляются прямоугольниками;
 2) каждый прямоугольник может иметь различные визуальные 
  атрибуты; 
 3) каждой сущности должно быть присвоено уникальное имя; 
 4) имена сущностей необходимо задавать в единственном числе; 
 5) связи на диаграмме представляются линиями, идущими от одной 
 сущности (таблицы) к другой; 
 6) каждой связи присваивается уникальное имя; 
 7) связанные таблицы разделяют на родительские и дочерние;
 8) родительские таблицы отображаются прямоугольниками с прямыми 
углами, дочерние – со скругленными

# 2.  Синхронизационные блокировки:

^3f802f

2 пункт (см. выше) находится в 13 лекции на [гугл диске препода по БД](https://drive.google.com/drive/folders/1sNQ3zOgOHoRsxtyAijtcMkTTgkGm3yc8)

## Чем являются синхр. блокировки:
Синхронизационные блокировки являются одним из двух подходов к сериализации транзакций.


**Метод синхронизационных блокировок** это подход, основанный на соблюдении двухфазного протокола синхронизационных захватов объектов баз данных (TwoPhase Locking Protocol, 2PL)

## Описание подхода 2PL:
(TwoPhase Locking Protocol)(2PL) Подход состоит в том, что _перед выполнением любой операции_ в транзакции T над объектом базы данных Q от имени транзакции T _запрашивается синхронизационная блокировка объекта_ Q в соответствующем режиме:
- Первая фаза транзакции (выполнение операций над базой данных) – **накопление блокировок**
- Вторая фаза (фиксация или откат) – **снятие блокировок**



## Режимы блокировок:
- S (Shared) - совместный режим, означающий совместную (по чтению) блокировку объекта. Такая блокировка требуется для операции чтения объекта.
- X (eXclusive) - монопольный режим, означающий монопольную (по записи) блокировку объекта. Требуется для выполнения операций вставки, удаления и модификации объекта.


## Уровни блокировок:
Для _согласования_ блокировок _разного уровня_ вводятся специальный протокол **гранулированных** блокировок и новые типы блокировок:
- Блокировка в режиме IS (Intented for Shared lock) некоторого составного объекта o базы данных означает намерение заблокировать некоторый объект o’, входящий в o, в _совместном_ режиме (режиме S). 
- Блокировка в режиме **IX** (Intented for eXclusive lock) некоторого составного объекта o базы данных означает намерение заблокировать некоторый объект o’, входящий в o, в _монопольном_ режиме (режиме X). 
- Блокировка в режиме **SIX** (Shared, Intented for eXclusive lock) некоторого составного объекта o базы данных означает _совместную блокировку всего этого объекта с намерением_ впоследствии блокировать какие-либо входящие в него объекты в монопольном режиме режиме X. 
	Например, если выполняется длинная операция просмотра таблицы Tab с возможностью удаления некоторых просматриваемых кортежей, то экономичнее всего заблокировать таблицу Tab в режиме SIX.

### Правила блокировок (фото):
![[Pasted image 20220703130229.png]]

## Блокировка объекта одной транзакцией по чтению не совместима с блокировкой другой транзакцией того же объекта по записи:
- никакая транзакция не может изменять объект, читаемый некоторой транзакцией (кроме самой этой транзакции)
- никакой транзакции нельзя читать объект, изменяемый некоторой транзакцией (кроме самой этой транзакции)
**Правила совместимости режимов**: ![[Pasted image 20220521150014.png]]


## Синхронизационные тупики, их распознавание и разрушение:
Независимо от вида протокола 2PL, всем методам блокировочных протоколов свойственна возможность возникновения тупиков (deadlocks) между транзакциями. 

Снизу показан простой сценарий возникновения синхронизационного тупика между транзакциями T1 и T2. Такой ориентированный граф называется _графом ожидания транзакций_. Циклы в таком графе обозначает синхронизационный тупик. Такие ситуации необходимо обнаруживать и искусственно устранять.
![[Pasted image 20220702130129.png]]


### Обнаружение тупиковых ситуаций:
В системе существует тупиковая ситуация в том и только в том случае, когда в графе ожидания транзакций имеется хотя бы один цикл. Для распознавания тупиковых ситуаций периодически производится построение графа ожидания транзакций, и в этом графе ищутся циклы.

Алгоритм редукции графа (на примере):
![[Pasted image 20220702131517.png]]

#### Алгоритм редукции графа ожидания:
- Удаляются все дуги от транзакций к объектам такие, что данная транзакция не ожидает блокировки каких-либо объектов. Если транзакции не ожидают удовлетворения запроса блокировок, то они не могут создавать тупика.
- Удаляются все дуги от объектов к транзакциям такие, что у транзакции нет заблокированных объектов. Если транзакции ожидают удовлетворения блокировок, но не удерживают заблокированных объектов, то они не могут создавать тупика.
- ![[Pasted image 20220702131637.png]]

- Для объектов без входящих дуг, но с исходящими дугами, ориентация одной произвольной исходящей дуги изменяется на противоположную - это моделирует удовлетворение запроса блокировки.
- Снова повторяются описанные действия с шага 1 до тех пор, пока не прекратится удаление дуг.
- Если в результате работы этого алгоритма в графе останутся дуги, то они обязательно образуют цикл.
- ![[Pasted image 20220702131710.png]]

![[Pasted image 20220702131808.png]]
### Разрушение тупиков:
Разрушение тупика начинается с выбора в цикле транзакции-жертвы, т.е. транзакции, которой решено пожертвовать, чтобы обеспечить возможность продолжения работы других транзакций. Критерии выбора транзакции:
- Транзакция, которая удерживает наибольшее число блокировок объектов
- Транзакция, которая существует в системе в течение наименьшего времени
- Случайным образом

Обычно при выборе транзакции-жертвы используется многофакторная оценка её стоимости.
После выбора транзакции-жертвы выполняется откат этой транзакции, который может носить полный или частичный (до некоторой точки сохранения) характер. При этом, естественно, освобождаются блокировки, и может быть продолжено выполнение других транзакций.











#### Определения:
  1) _Транзакция_ - это последовательность операций над БД, рассматриваемых СУБД как единое целое: либо все операции внутри транзакции выполняются, либо ни одна не выполняется. Транзакция в SQL – это несколько последовательных инструкций SQL, которые вместе образуют логическую единицу работы (unit of work).
  2) _ACID_ - Atomic (атомарность) Consistent (целостность) Isolation (изолированность) Durability (долговечность) 
  3) _Атомарность_ - результаты всех операций, успешно выполненных в пределах транзакции, должны быть отражены в состоянии базы данных, либо в состоянии базы данных не должно быть отражено действие ни одной операции. **Иногда называют "Все или ничего"**.
##### Все или ничего:
1) При успешном завершении транзакции оператором COMMIT
	- результаты гарантированно фиксируются во внешней памяти
	- смысл термина commit состоит в запросе «фиксации» результатов транзакции
1) При завершении транзакции оператором ROLLBACK 
	- результаты гарантированно отсутствуют во внешней памяти
	- смысл термина rollback состоит в запросе ликвидации результатов транзакции

##### Согласованность:
- Означает, что транзакция может быть успешно завершена с фиксацией результатов своих операций только в том случае, когда действия операций не нарушают целостность базы данных, т.е. удовлетворяют набору ограничений целостности, определенных для этой базы данных. 
- Это свойство расширяется тем, что во время выполнения транзакции разрешается устанавливать точки согласованности и явным образом проверять ограничения целостности. 

##### Изоляция:
- Требуется, чтобы две одновременно выполняемые транзакции никаким образом не действовали одна на другую. 
- Результаты выполнения операций транзакции T1 не должны быть видны никакой другой транзакции T2 до тех пор, пока транзакция T1 не завершится успешным образом.

##### Долговечность:
- После успешного завершения транзакции, все изменения, которые были внесены в состояние базы данных операциями этой транзакции, должны гарантированно сохраняться, даже в случае сбоев аппаратуры или программного обеспечения.


#### Целостность БД:

Часто база данных обладает такими ограничениями целостности, которые просто _невозможно не нарушить_, выполняя только один оператор изменения базы данных. Для поддержки подобных ограничений целостности допускается их нарушение внутри транзакции с тем условием, чтобы _к моменту завершения транзакции условия целостности были соблюдены_. 

_Начальная проверка_ _целостности_ БД проверяется при _первоначальной загрузке БД_, что гарантирует её целостность на момент выполнения некоторой транзакции T. Теперь эта транзакция фиксирует изменения операцией COMMIT: 
```
if (транзакция нарушает логическую целостность базы данных){
	откат изменений (ROLLBACK).
	} else {
	происходит фиксация.
}
```
И база данных всё равно в целостном состоянии.

#### Виды ограничения целостности:
1) **Немедленно проверяемые** - такие _ограничения_, _проверку_ которых _бессмысленно или даже невозможно откладывать_. При их нарушениях не производится откат транзакции, а лишь отвергается соответствующий оператор. 
2) **Откладываемые** - это _ограничения на базу данных_, а не на какие-либо отдельные операции. По умолчанию _такие ограничения проверяются при конце транзакции_, и их нарушение вызывает автоматическую замену оператора COMMIT на оператор ROLLBACK. 

#### Изолированность транзакций:
