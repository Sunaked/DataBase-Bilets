# Обработка запросов(Лекции 10-13)
## 1) Обработка запросов. Преобразование SQL-выражения во внутреннее представление СУБД.
-   Обзор     
-   Меры стоимости запросов
-   Операция выборки
-   Сортировка
-   Операция соединения
-   Другие операции 
-   Вычисления выражений
## Основные шаги обработки: 
1. Парсинг и трансляция
2. Оптимизация
3. Вычисление
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/1.png)
### Парсинг и трансляция
-   Осуществляется трансляция запроса в его внутреннюю форму. Затем осуществляется трансляция в реляционную алгебру.
-   Парсер осуществляет проверку синтаксиса и проверку отношений
### Вычисление
-   Механизм выполнения запросов принимает на вход план запросов, выполняет данный план, и возвращает ответ для запроса.
### Оптимизация
- Выражения реляционной алгебры могу иметь эквивалентные выражения
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/2.png)
-   Каждая операция реляционной алгебры может быть вычислена разными алгоритмами
-   Связанное выражение, уточняющее детальную стратегию выполнения называется планом вычислений (evaluation-plan)
	-   Используется индекс на salary, чтобы найти всех преподавателей с зп < 75000,
	-   Или производится полный скан(обход) отношения и убирает инструкторов с зп ≥ 75000
-   ***Оптимизация запросов***: Из всех эквивалентных планов выполнения выбирается с меньшей стоимостью. 
	-   Стоимость вычисляется с использованием статистической информации из каталога базы данных. 
		-   Например, число кортежей в каждом отношении, размер кортежей и т.д.   
## 2) Версионные методы управления транзакциями.
-   Основная идея версионных алгоритмов сериализации транзакций состоит в том, что в базе данных допускается существование нескольких «версий» одного и того же объекта.     
-   Эти алгоритмы, главным образом, направлены на преодоление конфликтов транзакций категорий R/W и W/R, позволяя выполнять операции чтения над некоторой предыдущей версией объекта базы данных. 
-   В результате операции чтения выполняются без задержек и тупиков, свойственных механизмам синхронизационных блокировок, а также без некоторых откатов, возможных при применении метода временных меток.**
### Версионный вариант метода временных меток
```
Транзакция - это последовательность операций над БД, рассматриваемых СУБД как единое целое: либо все операции внутри транзакции выполняются, либо ни одна не выполняется. 
Транзакция в SQL – это несколько последовательных инструкций SQL, которые вместе образуют логическую единицу работы (unit of work).
```
-   Multiversion Timestamp Ordering, `MVTO`
-   Порядок выполнения операций одновременно выполняемых транзакций задается порядком временных меток, которые получают транзакции во время старта.
-   Временные метки также используются для идентификации версий данных при чтении и модификации – каждая версия получает временную метку той транзакции, которая её записала.
-   Алгоритм не только следит за порядком выполнения операций транзакций, но также отвечает за преобразование операций над объектами базы данных в операции над версиями этих объектов, т.е. каждая операция над объектом базы данных o преобразуется в соответствующую операцию над некоторой версией объекта _o_.
Алгоритм `MVTO` работает следующим образом:
<details><summary>Info about subindexes</summary>
<p>
Ri, Rj, Ti, Tk, Wi, oi, ok - i, j, k являются нижними индексами
</p>
</details>
1.  Любая операция R_i(o) преобразуется в операцию R_i(ok), где ok – это версия объекта o, помеченная наибольшей временной меткой t(T_k), такой что t(T_k) ≤ t(T_i).
2.  Операция Wi(o) обрабатывается следующим образом:
 -   Если уже обработана операция Rj(ok), такая что t(Tk) ≤ t(Ti) < t(Tj), то операция W_i(o) отменяется, а транзакция T_i откатывается.
-   В противном случае Wi(o) преобразуется в W_i(oi).
3.  Завершение (`COMMIT`) любой транзакции T откладывается до завершения всех транзакций, записавших версии объектов, которые прочитала T.
-   При откате любой транзакции уничтожаются все созданные ею версии объектов базы данных и откатываются все транзакции, прочитавшие хотя бы одну из этих версий («каскадные» откаты).
-   Основные преимущества алгоритма `MVTO` - это отсутствие задержек и откатов при выполнении операций чтения, а основной недостаток – возможность возникновения каскадных откатов транзакций при выполнении операций записи. 
-   Кроме того, в базе данных может накапливаться произвольное число версий одного и того же объекта, и определение того, какие версии больше не требуются, является серьезной технической проблемой.

### Версионный вариант протокола 2PL
-   Two-Version Two-Phase Locking Protocol, `2V2PL`
-   Поддерживается до двух версий объектов базы данных
-   Текущей версией объекта базы данных будем называть версию, созданную зафиксированной транзакцией с наиболее поздним временем фиксации. Незафиксированной версией объекта БД – версию, созданную еще незавершившейся транзакцией. 
-   В соответствии с протоколом `2V2PL`, в каждый момент времени существует не более одной незафиксированной версии каждого объекта базы данных.
#### Операции любой транзакции Ti над объектом базы данных o обрабатываются следующим образом:
<details><summary>Info about subindexes</summary>
<p>
Ri, Rj, Ti, Tk, Wi, oi, ok - i, j, k являются нижними индексами
</p>
</details>
1.  Операция Ri(o) немедленно выполняется над текущей версией объекта o
2.  Операция Wi(o), приводящая к созданию новой версии объекта o, выполняется только после завершения транзакции, создавшей незафиксированную версию объекта o
3.  Выполнение операции `COMMIT` откладывается до тех пор, пока не завершатся все транзакции Tk, прочитавшие текущие версии объектов базы данных, которые должны замениться незафиксированными версиями этих объектов, созданными транзакцией Ti

#### Для реализации такого поведения используются специальные виды синхронизационных блокировок:
-   `RL (Read Lock)` – в этом режиме блокируется любой объект базы данных o перед выполнением операции чтения его текущей версии. Удержание этой блокировки до конца транзакции гарантирует, что при повторном чтении объекта o будет прочитана та же версия этого объекта.
-   `WL (Write Lock)` – в этом режиме блокируется любой объект базы данных o перед выполнением операции, приводящей к созданию новой (незафиксированной) версии этого объекта. Удержание этой блокировки до конца транзакции гарантирует, что в любой момент времени будет существовать не более одной незафиксированной версии любого объекта базы данных.
-   `CL (Commit Lock)` – блокировка устанавливается во время выполнения операции `COMMIT` транзакции и затрагивает любой объект базы данных, новую версию которого создала данная транзакция. Удовлетворение этой блокировки для данной транзакции гарантирует, что завершились все транзакции, читавшие текущие версии объектов, новые версии которых были созданы при выполнении данной транзакции, и, следовательно, их можно заменить.
![slice-link](https://raw.githubusercontent.com/Sunaked/DataBase-Bilets/main/Exam/Bilets/images/3.png)
### Версионно-блокировочный протокол сериализации транзакций для поддержки только читающих транзакций
-   Multiversion Protocol for Read-Only Transactions, `ROMV`
-   Гибридный протокол, поддерживающий эффективное выполнение транзакций, не изменяющих состояние базы данных
-   При применении этого протокола при образовании каждой транзакции явно указывается её тип – только читающая (read-only) или изменяющая (update) транзакция. В только читающих транзакциях допускается использование только операций чтения объектов базы данных, а в изменяющих транзакциях – операций и чтения, и записи.
### Romv
-   Изменяющие транзакции выполняются в соответствии с обычным протоколом `2PL`, т.е. перед выполнением операции над объектом базы данных o этот объект должен быть заблокирован до конца изменяющей транзакции. Каждая операции записи объекта o создает его новую версию, которая при завершении транзакции помечается временной меткой, соответствующей моменту фиксации этой транзакции.
-   Каждая только читающая транзакция при своем образовании получает соответствующую временную метку. При выполнении операции чтения объекта базы данных o транзакция получает доступ к версии объекта o, образованной изменяющей транзакцией, которая хронологически последней зафиксировалась к моменту образования данной читающей транзакции.
-   Основным плюсом по сравнению с протоколом `2V2PL` является принципиальное отсутствие синхронизационных задержек при выполнении операций чтения только читающих транзакций.     
-   В сравнении с `MVTO`, `ROMV` выигрывает в принципиальном отсутствии откатов только читающих транзакций. 
-   При использовании протокола `ROMV` в базе данных может возникать произвольное число версий объектов. Требуется создание специального сборщика мусора, который должен удалять ненужные версии данных.