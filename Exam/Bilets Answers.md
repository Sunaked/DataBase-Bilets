#вуз  #БД  #данные  #билеты #экзамен 

## Билеты:
### Билет 1:
### Билет 2:

##### 1.  Семантическая модель Entity-Relationship, E/R-диаграммы:
###### При построении ER-модели используются следующие принципы: 
 1) сущности на диаграмме представляются прямоугольниками;
 2) каждый прямоугольник может иметь различные визуальные 
  атрибуты; 
 3) каждой сущности должно быть присвоено уникальное имя; 
 4)имена сущностей необходимо задавать в единственном числе; 
 5) связи на диаграмме представляются линиями, идущими от одной 
 сущности (таблицы) к другой; 
 6) каждой связи присваивается уникальное имя; 
 7) связанные таблицы разделяют на родительские и дочерние;
 8) родительские таблицы отображаются прямоугольниками с прямыми 
углами, дочерние – со скругленными

##### 2.  Синхронизационные блокировки:

  

### Билет 3:

1. Проектирование реляционных схем с использованием ER-диаграмм.:
	Чтобы построить реляционную схему из ER-диаграмм нужно:
    
    1

### Билет 4:
### Билет 5:
### Билет 6:
### Билет 7:
### Билет 8:

##### 1. Вычисление SQL-выражений. Материализация.
1) Для вычисления выражений, содержащих несколько реляционных операций, существует несколько вариантов вычисления. Если каждая операция вычисляется отдельно и результатом такого шага является временное отношение, то такая ситуация называется материализацией. Альтернативным способом является организация конвейра (pipeline) выполнения параллельных операций.

2) Материализация. Материализованное вычисление представляет собой последовательность вычислений, в которой создается каждая промежуточная операция (материализуется) и используется для вычислений дальнейших шагов. Для вычисления стоимости требуется добавить стоимость всех операций и стоимости записи временных результатов на диск. Одним из вариантов оптимизаций является двойная буферизация (один из буферов осуществляет вычисление, а другой - запись)

##### 2. Синхронизационные тупики, их распознавание и разрушение.
1) Независимо от вида протокола 2PL, всем методам блокировочных протоколов свойствена возмодность возникновения тупиков (deadlocks) между транзакциями.

2) Основой обнаружения тупиковых ситуаций является построение или постоянное поддерживание графа ожидания транзакций. Граф ожидания транзакций - это двудольный ориентированный граф, вершины которого соответствуют либо транзакциям, либо объектам блокировок.

3) Разрушение тупиков. Нужно каким-то образом обеспечить воможность продолжения работы хотя бы для части транзакций, попавших в тупик. Разрушение тупика начинается с выбора в цикле транзакции-жертвы, т.е. транзакции, которой решено пожертвовать, чтобы обеспечить возмодность продолжения работы других транзакций. Для этого могут использоваться различные, зачастую противоречивые критерии: транзакция, которая удерживает наибольшее число блокировок объектов; транзакция, которая существует в системе в течение наименьшего времени; можно выбрать транзакцию-жертву случайным образом. Обычно при выборе транзакции-жертвы используется многофакторная офенка её стоимости, в которую с разными весами входят время выполнения, число накопленных блокировок, приоритет и т.д. В качестве "жертвы" выбирается транзакция, для которой эта оценка выдает наиболее подходящий результат. После выбора транзакции-жертвы выполняется откат этой транзакции, который может носить полный или частичный (до некоторой точки сохранения) характер. При этом, естественно, освобождаются блокировки, и может быть продолжено выполнение других транзакций.

### Билет 9:
#### 1. Вычисление SQL-выражений. Конвейер.

##### Вычисление выражений.
- Вычисление выражений, содержащих несколько реляционных операций, существует несколько вариантов вычисления. Если каждая операция вычисляется отдельно и результатом такого шага является временное отношение, то такая ситуация называется материализацией. Альтернативным способом является организация конвейра (pipeline) выполнения параллельных операций.

##### Конвейер. 
- Уменьшает стоимость чтения и записи временных отношений. Довольно быстрый отклик в передаче результатов запроса, если план запроса позволяет полноценный конвейер.
###### Конвейер бывает 2х типов:
1) Demand-driven (Ленивое вычисление). Demand-driven - результат запроса операций низкого уровня не передается автоматически на более высокий уровень. Он будет передан, когда будет осуществлен запрос более высокого уровня.
2) Producer-driven (Жадное вычисление). Producer-driven - операции не ждут запрос для вычисления кортежей. Каждая операция в producer-driven конвейере моделируется как отдельный процесс или поток в системе, которая на вход принимает поток кортежей и на выходе также поток кортежей.


##### Реализация конвейера вычислений.
1) Каждая операция в ленивом конвейере может быть разработана как итератор, который предоставляет следующие функции: open(), next(), close().
2) После вызова open(), каждое обращение к next() возвращает следующий кортеж на выход операции. 
3) Функция close() сообщает итератору, что больше кортежей не требуется.
4) Итератор хранит состояние вычисления между вызовами. Конвейеры с жадным вычислением реализованы другим образом.
5) Для каждой смежной пары операций в конвейере, система создает буфер для фиксации кортежей, передающиеся с одной операции на другую.
6) Процессы (или потоки) разных операций работаю параллельно. Каждая операция внизу кортежа последовательно вычисляет кортежи для вывода, и передает его в буфер вывода, до момента переполнения буфера.
7) Как только операция использует кортеж из входного буфера, он удаляется из буфера.
8) Если буфер вывода полный, то операция ожидает забор данных из буфера более высокоуровневой операцией. Существует возможность распараллеливания операций внутри конвейера в случае многопроцессорных систем.

#### 2. Нормализация БД.
- Цель нормализации: исключить избыточное дублирование данных, которое является причиной аномалий, возникших при добавлении, редактировании и удалении кортежей (строк таблицы).
- Нормальная форма — требование, предъявляемое к структуре таблиц в теории реляционных баз данных для устранения из базы избыточных функциональных зависимостей между атрибутами (полями таблиц).
- Метод нормальных форм (НФ) состоит в сборе информации о объектах решения задачи в рамках одного отношения и последующей декомпозиции этого отношения на несколько взаимосвязанных отношений на основе процедур нормализации отношений.

##### 1НФ:
- Отношение находится в 1НФ, если все его атрибуты являются простыми, все используемые домены должны содержать только скалярные значения. Не должно быть повторений строк в таблице.

##### 2НФ:
- Отношение находится во 2НФ, если оно находится в 1НФ и каждый не ключевой атрибут неприводимо зависит от Первичного Ключа (ПК). Неприводимость означает, что в составе потенциального ключа отсутствует меньшее подмножество атрибутов, от которого можно также вывести данную функциональную зависимость.

##### 3НФ:
- Переменная отношения находится в третьей нормальной форме тогда и только тогда, когда она находится во второй нормальной форме, и отсутствуют транзитивные функциональные зависимости неключевых атрибутов от ключевых.

###### Нормальная форма Бойса-Кодда (НФБК):
- Определение 3НФ не совсем подходит для следующих отношений:
1) отношение имеет два или более потенциальных ключа;
2) два и более потенциальных ключа являются составными;
3) они пересекаются, т.е. имеют хотя бы один общий атрибут.
- Для отношений, имеющих один потенциальный ключ (первичный), НФБК является 3НФ.
- Отношение находится в НФБК, когда каждая нетривиальная и неприводимая слева функциональная зависимость обладает потенциальным ключом в качестве детерминанта.
- Переменная отношения находится в нормальной форме Бойса — Кодда (иначе — в усиленной третьей нормальной форме) тогда и только тогда, когда каждая её нетривиальная и неприводимая слева функциональная зависимость имеет в качестве своего детерминанта некоторый потенциальный ключ.

##### 4НФ:
- Переменная отношения находится в четвёртой нормальной форме, если она находится в нормальной форме Бойса — Кодда и не содержит нетривиальных многозначных зависимостей. В отношении R (A, B, C) существует многозначная зависимость R.A->R.B в том и только в том случае, если множество значений B, соответствующее паре значений A и C, зависит только от A и не зависит от С.

##### 5НФ:
- Отношения находятся в 5НФ, если оно находится в 4НФ и отсутствуют сложные зависимые соединения между атрибутами. Если «Атрибут_1» зависит от «Атрибута_2», а «Атрибут_2» в свою очередь зависит от «Атрибута_3», а «Атрибут_3» зависит от «Атрибута_1», то все три атрибута обязательно входят в один кортеж.

###### Доменно-ключевая нормальная форма (ДКНФ):
- Переменная отношения находится в ДКНФ тогда и только тогда, когда каждое наложенное на неё ограничение является логическим следствием ограничений доменов и ограничений ключей, наложенных на данную переменную отношения.
- Ограничение домена – ограничение, предписывающее использовать для определённого атрибута значения только из некоторого заданного домена. Ограничение по своей сути является заданием перечня (или логического эквивалента перечня) допустимых значений типа и объявлением о том, что указанный атрибут имеет данный тип.
- Ограничение ключа – ограничение, утверждающее, что некоторый атрибут или комбинация атрибутов является потенциальным ключом.
- Любая переменная отношения, находящаяся в ДКНФ, обязательно находится в 5НФ. Однако не любую переменную отношения можно привести к ДКНФ.

##### 6НФ:
- Переменная отношения находится в шестой нормальной форме тогда и только тогда, когда она удовлетворяет всем нетривиальным зависимостям соединения. Из определения следует, что переменная находится в 6НФ тогда и только тогда, когда она неприводима, то есть не может быть подвергнута дальнейшей декомпозиции без потерь. 

### Билет 10:
#### 1. Оптимизация запросов.
##### Что это:

1) Оптимизация запросов – процесс выбора наиболее эффективного плана из одной или многих стратегий, которые могут быть применены для обработки запросов.
2) Один из пунктов оптимизации возникает на уровне реляционной алгебры, когда система пытается найти выражение, которое эквивалентно указанному выражению, но наиболее эффективно для вычисления.
3) Другой пункт оптимизации – это выбор детализированной стратегии для обработки запроса, такой как выбор алгоритма для выполнения операции.

##### Общий план поиска.
1) Для каждого плана посчитать стоимость, выбрать наименьший.
Берете план запроса и делаете цикл:
```
для каждого нового элемента
	для каждого правила
		пытаемся создать выражение на основе правила эквивалентности
		если выражение новое, добавляем в список
```
2) Получение всевозможных эквивалентных планов запроса.
3) По каждому логическому запросу сгенерировать всевозможные физические планы запросов.

##### Возможные оптимизации.
- Использование указателей на подмножества планов.
- Уменьшение количества генерируемых планов запроса (на основе эвристик и стат. данных).
- используется информация из системного каталога (INFORMATION_SCHEMA).
- Разделяй и властвуй для физ. планов.
- Кэширование планов.

##### INFORMATION_SCHEMA.
- Количество кортежей в отношении - n(r).
- Количество блоков, содержащих кортежи отношения - b(r).
- Данные об устройстве кортежа.
- Распределение количества кортежей в блоке - f(r).
- Гистограмма уникальных значений в таблице по полям.
- b(r) ≈ n(r)/f(r)


#### 2. Метод временных меток.

##### Основная идея метода временных меток (Timestamp Ordering, TO), состоит в следующем:
1) Если транзакция T1 началась раньше транзакции T2, то система обеспечивает такой сериальный план, как если бы транзакция T1 была целиком выполнена до начала T2. Для этого каждой транзакции T предписывается временная метка t(T), соответствующая времени начала выполнения транзакции T.
2) При выполнении операции над объектом o транзакция T помечает его своими идентификатором, временной меткой и типом операции (чтение или изменение).

3) Перед выполнением операции над объектом o транзакция T2 выполняет следующие действия:
4) Проверяет, помечен ли объект o какой-либо транзакцией T1. Если не помечен, то помечает этот объект своей временной меткой и типом операции и выполняет операцию.
5) Иначе (если o помечен T1) транзакция T2 проверяет, не завершилась ли транзакция T1, пометившая этот объект. Если транзакция T1 закончилась, то T2 помечает объект o и выполняет свою операцию.
6) Иначе (если T1 не завершилась) T2 проверяет конфликтность операций. Если операции неконфликтны, то при объекте o запоминается идентификатор транзакции T2, остается или проставляется временная метка с меньшим значением, и транзакция T2 выполняет свою операцию.

7) Иначе (если операции транзакций T2 и T1 конфликтуют), то если t(T2) > t(T1) (т.е. транзакция T1 «моложе» T2), то производится откат T1 и всех других транзакций, идентификаторы которых сохранены при объекте o, и T2 выполняет свою операцию.
8) Если же t(T2) ≤ t(T1) (T1 «старше» T2), то производится откат T2, и T2 получает новую временную метку и начинается заново.
##### К недостаткам метода TO относятся:
- Потенциально более частые откаты транзакций, чем в случае использования синхронизационных захватов. Это связано с тем, что конфликтность транзакций определяется более грубо. Но в распределенных системах эти недостатки окупаются тем, что не нужно распознавать тупики, а построение графа ожидания в распределенных системах стоит очень дорого.

### Билет 11:
### Билет 12:
### Билет 13:
